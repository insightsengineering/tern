% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_checkmate.R
\name{assertions}
\alias{assertions}
\alias{assert_list_of_variables}
\alias{assert_df_with_variables}
\alias{assert_valid_factor}
\alias{assert_df_with_factors}
\alias{is_equal_length}
\alias{is_proportion}
\alias{is_proportion_vector}
\alias{is_quantiles_vector}
\alias{all_elements_in_ref}
\alias{has_tabletree_colnames}
\title{Additional Assertions for \code{checkmate}}
\usage{
assert_list_of_variables(x, .var.name = checkmate::vname(x), add = NULL)

assert_df_with_variables(
  df,
  variables,
  na_level = NULL,
  .var.name = checkmate::vname(df),
  add = NULL
)

assert_valid_factor(
  x,
  min.levels = 1,
  max.levels = NULL,
  any.missing = TRUE,
  .var.name = checkmate::vname(x),
  add = NULL
)

assert_df_with_factors(
  df,
  variables,
  min.levels = 1,
  max.levels = NULL,
  any.missing = TRUE,
  na_level = NULL,
  .var.name = checkmate::vname(df),
  add = NULL
)

is_equal_length(...)

is_proportion(x, include_boundaries = FALSE)

is_proportion_vector(x, include_boundaries = FALSE)

is_quantiles_vector(x, include_boundaries = FALSE)

all_elements_in_ref(x, ref)

has_tabletree_colnames(x, col_names)
}
\arguments{
\item{x}{object to test}

\item{df}{supposed data frame to test}

\item{variables}{(named \code{list} of \code{character})\cr supposed variables list to test}

\item{na_level}{(\code{string})\cr the string user has been using to represent NA or
missing data. For \code{NA} values please consider using directly \code{base::is.na} or
similar approaches.}

\item{min.levels}{Minimum number of levels for \code{x}.}

\item{max.levels}{Maximum number of levels for \code{x}.}

\item{any.missing}{Default is \code{TRUE}, allowing missing values (\code{NA}).}

\item{...}{a collection of objects to test.}

\item{include_boundaries}{(\code{logical})\cr whether to include boundaries when testing for proportions.}

\item{ref}{(\code{vector})\cr where matches from \code{x} are sought for \code{all_elements_in_ref}.}

\item{col_names}{(\code{character})\cr column names which should be present in the table.}
}
\description{
We provide additional assertion functions which can be used together with \code{\link[checkmate:assert]{checkmate::assert()}}.
}
\section{Functions}{
\itemize{
\item \code{assert_list_of_variables}: Check whether \code{x} is a valid list of variable names.
\code{NULL} elements of the list \code{x} are dropped out with \code{Filter(Negate(is.null), x)}.

\item \code{assert_df_with_variables}: Check whether \code{df} is a data frame with the analysis \code{variables}.
Please notice how this produces an error when not all variables are present in the
data.frame while the opposite is not required.

\item \code{assert_valid_factor}: Check whether \code{x} is a valid factor (has levels and no empty string levels).
Note that \code{NULL} and \code{NA} elements are allowed.

\item \code{assert_df_with_factors}: Check whether \code{df} is a data frame where the analysis \code{variables}
are all factors. Note that the creation of \code{NA} by direct call of \code{factor()} will
trim \code{NA} levels out of the vector list itself.

\item \code{is_equal_length}: Check that objects provided are of same length.

\item \code{is_proportion}: Check whether \code{x} is a proportion: number between 0 and 1.

\item \code{is_proportion_vector}: Check whether \code{x} is a vector of proportions (numbers between 0 and 1).

\item \code{is_quantiles_vector}: Check whether \code{x} is a sorted vector of unique quantile proportions
(numbers between 0 and 1).

\item \code{all_elements_in_ref}: Check whether all elements of \code{x} are in a reference vector.

\item \code{has_tabletree_colnames}: Check whether \code{rtables} object \code{x} has the specified column names.
}}

\examples{
# Check whether `x` is a valid list of variable names.
tern:::assert_list_of_variables(list(val = "a"))
tern:::assert_list_of_variables(list(val = c("a", "b")))
tern:::assert_list_of_variables(list(val = c("a", "b"), val2 = NULL))

# The following calls fail
\dontrun{
tern:::assert_list_of_variables(list(1, 2))
tern:::assert_list_of_variables(list("bla" = 2))
}

# Check whether `df` contains the analysis `variables`.
tern:::assert_df_with_variables(df = data.frame(a = 5, b = 3),
variables = list(val = "a"))
tern:::assert_df_with_variables(df = data.frame(a = 5, b = 3),
variables = list(val = c("a", "b")))
tern:::assert_df_with_variables(df = data.frame(a = 5, b = 3),
variables = list(val = c("a", "b")))
tern:::assert_df_with_variables(df = data.frame(a = 5, b = 3, e = "<Missing>"),
variables = list(val = c("a", "b")), na_level = "<Missing>")

# The following calls fail
\dontrun{
tern:::assert_df_with_variables(df = matrix(1:5, ncol = 2, nrow = 3),
variables = list(val = "a"))
tern:::assert_df_with_variables(df = data.frame(a = 5, b = 3),
variables = list(val = c("a", "b", "c")))
tern:::assert_df_with_variables(df = data.frame(a = 5, b = 3, e = "<Missing>"),
variables = list(val = c("a", "b", "e")), na_level = "<Missing>")
}

# Check whether `x` is a valid factor.
tern:::assert_valid_factor(factor(c("a", "b")))
tern:::assert_valid_factor(factor(c("a", NULL)))
tern:::assert_valid_factor(factor(c("a", NA)), any.missing = TRUE)
tern:::assert_valid_factor(factor("A", levels = c("A", "B")))

# The following calls fail
\dontrun{
# tern:::assert_valid_factor(-1)
# tern:::assert_valid_factor(factor(c("a", "")))
# tern:::assert_valid_factor(factor(c("a", NA)), any.missing = FALSE)
# tern:::assert_valid_factor(factor(NULL))
# tern:::assert_valid_factor(factor(c(NULL, "")))
# tern:::assert_valid_factor(factor())
}

# Check whether `df` contains all factor analysis `variables`.
adf <- data.frame(a = factor(c("A", "B")), b = 3)
bdf <- data.frame(a = factor(letters[1:3]), b = factor(c(1, 2, 3)), d = 3)
assert_df_with_factors(df = adf, variables = list(val = "a"))
assert_df_with_factors(df = adf, variables = list(val = "a"), min.levels = 1)
assert_df_with_factors(df = adf, variables = list(val = "a"), min.levels = 2, max.levels = 2)
assert_df_with_factors(
df = data.frame(a = factor(c("A", NA, "B")), b = 3),
variable = list(val = "a"),
min.levels = 2,
max.levels = 2
)
# The following calls fail
\dontrun{
assert_df_with_factors(df = adf, variables = list(val = "a"), min.levels = 1, max.levels = 1)
assert_df_with_factors(df = adf, variables = list(val = "a"), min.levels = 1, max.levels = 1)
assert_df_with_factors(df = adf, variables = list(val = "a", val = "b", val = ""))
assert_df_with_factors(df = adf, variables = list(val = "a", val = "b", val = "d"))
assert_df_with_factors(df = bdf, variables = list(val = "a", val = "b"), min.levels = 1, max.levels = 1)
}


#' # Check whether `x` is a valid list of variable names.
a <- 1
b <- NULL
c <- c(1, "car")
d <- 5
is_equal_length(a, b, c, d)

# Check whether `x` is between 0 and 1.
is_proportion(x = 0.3)
is_proportion(x = 1.3)
is_proportion(x = 0, include_boundaries = TRUE)

# Check whether `x` is a vector of numbers between 0 and 1.
is_proportion_vector(c(0.3, 0.1))
is_proportion_vector(c(1.3, 0.1))
is_proportion_vector(0, include_boundaries = TRUE)

# Check whether `x` is a vector of sorted quantile proportions between 0 and 1.
is_quantiles_vector(c(0.1, 0.3))
is_quantiles_vector(c(0.3, 0.1))
is_quantiles_vector(c(0.3, 0.3))
is_quantiles_vector(0, include_boundaries = TRUE)

# Check whether all elements of `x` are in a reference vector.
all_elements_in_ref(c("a", "b"), c("a", "b", "c"))
all_elements_in_ref(c("a", "d"), c("a", "b", "c"))
all_elements_in_ref(c(1:3), c(1:5))
}
\keyword{internal}
