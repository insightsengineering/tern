% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_checkmate.R
\name{assertions}
\alias{assertions}
\alias{assert_list_of_variables}
\alias{assert_df_with_variables}
\alias{assert_valid_factor}
\alias{assert_df_with_factors}
\alias{assert_proportion_value}
\title{Additional Assertions for \code{checkmate}}
\usage{
assert_list_of_variables(x, .var.name = checkmate::vname(x), add = NULL)

assert_df_with_variables(
  df,
  variables,
  na_level = NULL,
  .var.name = checkmate::vname(df),
  add = NULL
)

assert_valid_factor(
  x,
  min.levels = 1,
  max.levels = NULL,
  null.ok = TRUE,
  any.missing = TRUE,
  n.levels = NULL,
  len = NULL,
  .var.name = checkmate::vname(x),
  add = NULL
)

assert_df_with_factors(
  df,
  variables,
  min.levels = 1,
  max.levels = NULL,
  any.missing = TRUE,
  na_level = NULL,
  .var.name = checkmate::vname(df),
  add = NULL
)

assert_proportion_value(x, include_boundaries = FALSE)
}
\arguments{
\item{x}{(\code{any})\cr object to test.}

\item{.var.name}{[\code{character(1)}]\cr
Name of the checked object to print in assertions. Defaults to
the heuristic implemented in \code{\link[checkmate]{vname}}.}

\item{add}{[\code{AssertCollection}]\cr
Collection to store assertion messages. See \code{\link[checkmate]{AssertCollection}}.}

\item{df}{(\code{data.frame})\cr data set to test.}

\item{variables}{(named \code{list} of \code{character})\cr list of variables to test.}

\item{na_level}{(\code{character})\cr the string you have been using to represent NA or
missing data. For \code{NA} values please consider using directly \code{\link[=is.na]{is.na()}} or
similar approaches.}

\item{min.levels}{[\code{integer(1)}]\cr
Minimum number of factor levels.
Default is \code{NULL} (no check).}

\item{max.levels}{[\code{integer(1)}]\cr
Maximum number of factor levels.
Default is \code{NULL} (no check).}

\item{null.ok}{[\code{logical(1)}]\cr
If set to \code{TRUE}, \code{x} may also be \code{NULL}.
In this case only a type check of \code{x} is performed, all additional checks are disabled.}

\item{any.missing}{[\code{logical(1)}]\cr
Are vectors with missing values allowed? Default is \code{TRUE}.}

\item{n.levels}{[\code{integer(1)}]\cr
Exact number of factor levels.
Default is \code{NULL} (no check).}

\item{len}{[\code{integer(1)}]\cr
Exact expected length of \code{x}.}

\item{include_boundaries}{(\code{logical})\cr whether to include boundaries when testing
for proportions.}

\item{(`integer`)\cr}{minimum number of factor levels. Default is \code{1}.}

\item{...}{a collection of objects to test.}
}
\value{
Nothing if assertion passes, otherwise prints the error message.
}
\description{
Additional assertion functions which can be used together with the \code{checkmate} package.
}
\section{Functions}{
\itemize{
\item \code{assert_list_of_variables()}: Checks whether \code{x} is a valid list of variable names.
\code{NULL} elements of the list \code{x} are dropped with \code{Filter(Negate(is.null), x)}.

\item \code{assert_df_with_variables()}: Check whether \code{df} is a data frame with the analysis \code{variables}.
Please notice how this produces an error when not all variables are present in the
data.frame while the opposite is not required.

\item \code{assert_valid_factor()}: Check whether \code{x} is a valid factor (i.e. has levels and no empty
string levels). Note that \code{NULL} and \code{NA} elements are allowed.

\item \code{assert_df_with_factors()}: Check whether \code{df} is a data frame where the analysis \code{variables}
are all factors. Note that the creation of \code{NA} by direct call of \code{factor()} will
trim \code{NA} levels out of the vector list itself.

\item \code{assert_proportion_value()}: Check whether \code{x} is a proportion: number between 0 and 1.

}}
\examples{
# Check whether `x` is a valid list of variable names.

# Internal function - assert_list_of_variables
\dontrun{
assert_list_of_variables(list(val = "a"))
assert_list_of_variables(list(val = c("a", "b")))
assert_list_of_variables(list(val = c("a", "b"), val2 = NULL))

# The following calls fail
assert_list_of_variables(list(1, 2))
assert_list_of_variables(list("bla" = 2))
}

# Check whether `df` contains the analysis `variables`.

# Internal function - assert_df_with_variables
\dontrun{
assert_df_with_variables(
  df = data.frame(a = 5, b = 3),
  variables = list(val = "a")
)
assert_df_with_variables(
  df = data.frame(a = 5, b = 3),
  variables = list(val = c("a", "b"))
)
assert_df_with_variables(
  df = data.frame(a = 5, b = 3),
  variables = list(val = c("a", "b"))
)
assert_df_with_variables(
  df = data.frame(a = 5, b = 3, e = "<Missing>"),
  variables = list(val = c("a", "b")), na_level = "<Missing>"
)

# The following calls fail
assert_df_with_variables(
  df = matrix(1:5, ncol = 2, nrow = 3),
  variables = list(val = "a")
)
assert_df_with_variables(
  df = data.frame(a = 5, b = 3),
  variables = list(val = c("a", "b", "c"))
)
assert_df_with_variables(
  df = data.frame(a = 5, b = 3, e = "<Missing>"),
  variables = list(val = c("a", "b", "e")), na_level = "<Missing>"
)
}

# Check whether `x` is a valid factor.

# Internal function - assert_valid_factor
\dontrun{
assert_valid_factor(factor(c("a", NULL)))
assert_valid_factor(factor(c("a", "b")))
assert_valid_factor(factor(c("a", "b")), len = 2)
assert_valid_factor(factor(c("a", NA)), any.missing = TRUE)
assert_valid_factor(factor("A", levels = c("A", "B")))

# The following calls fail
assert_valid_factor(-1)
assert_valid_factor(factor(c("a", "")))
assert_valid_factor(factor(c("a", NA)), any.missing = FALSE)
assert_valid_factor(factor(NULL))
assert_valid_factor(factor(c(NULL, "")))
assert_valid_factor(factor())
}

# Check whether `df` contains all factor analysis `variables`.
adf <- data.frame(a = factor(c("A", "B")), b = 3)
bdf <- data.frame(a = factor(letters[1:3]), b = factor(c(1, 2, 3)), d = 3)

# Internal function - assert_df_with_factors
\dontrun{
assert_df_with_factors(df = adf, variables = list(val = "a"))
assert_df_with_factors(df = adf, variables = list(val = "a"), min.levels = 1)
assert_df_with_factors(df = adf, variables = list(val = "a"), min.levels = 2, max.levels = 2)
assert_df_with_factors(
  df = data.frame(a = factor(c("A", NA, "B")), b = 3),
  variable = list(val = "a"),
  min.levels = 2,
  max.levels = 2
)

# The following calls fail
assert_df_with_factors(df = adf, variables = list(val = "a"), min.levels = 1, max.levels = 1)
assert_df_with_factors(df = adf, variables = list(val = "a"), min.levels = 1, max.levels = 1)
assert_df_with_factors(df = adf, variables = list(val = "a", val = "b", val = ""))
assert_df_with_factors(df = adf, variables = list(val = "a", val = "b", val = "d"))
assert_df_with_factors(
  df = bdf,
  variables = list(val = "a", val = "b"),
  min.levels = 1,
  max.levels = 1
)
}

# Check whether `x` is between 0 and 1.
# Internal function - assert_proportion_value
\dontrun{
assert_proportion_value(x = 0, include_boundaries = TRUE)
assert_proportion_value(x = 0.3)

# These fail
assert_proportion_value(x = 1.3)
assert_proportion_value(x = 1)
}

}
\keyword{internal}
