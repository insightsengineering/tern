---
title: "Tern Formatting"
date: "2022-03-09"
output:
    rmarkdown::html_document:
        theme: "spacelab"
        highlight: "kate"
        toc: true
        toc_float: true
vignette: >
    %\VignetteIndexEntry{Tern Formatting}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
editor_options:
    markdown: 
        wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## `tern::formatting_functions` Overview

The `tern` R package provides functions to create common analyses from clinical trials in `R` and these functions 
have default formatting arguments for displaying the values in the output a specific way. 

The `tern` formatting differs compared to the formatting available in the `formatters` package as `tern` 
formats are capable of handling logical statements, allowing you have more control on how the output is displayed. 
Depending what the value is, the format of the output will change. Whereas when using `formatters` you specify one 
specific format that all values will inherit. 

To see the available format functions available in `tern` see `?tern::formatting_functions`.
To see the available format strings available in `formatters` see `formatters::list_valid_format_labels()`


## Examples of using both `tern::formatting_functions` & `formatters`

The packages used in this vignette are:

```{r, message=FALSE}
library(rtables)
library(formatters)
library(tern)
library(dplyr)
```

In the example below demonstrates the use of `tern` formatting using the `tern::count_abnormal` function. The example
shows only "low" values having a numerator value and the output displays a fraction and a percentage value, while
the "high" value doesn't have a numerator value and so no percentage value is displayed, only a fraction.

```{r}
df2 <- data.frame(
  ID = as.character(c(1, 1, 2, 2)),
  RANGE = factor(c("NORMAL", "LOW", "HIGH", "LOW")),
  BL_RANGE = factor(c("NORMAL", "NORMAL", "HIGH", "HIGH")),
  ONTRTFL = c("", "Y", "", "Y"),
  stringsAsFactors = FALSE
)

df2 <- df2 %>%
  filter(ONTRTFL == "Y")

basic_table() %>%
  count_abnormal(
    var = "RANGE",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "ID", baseline = "BL_RANGE"),
    exclude_base_abn = FALSE,
    .formats = list(fraction = format_fraction)
  ) %>%
  build_table(df2)
```
In this example the `tern::count_abnormal` function is utilized again, this time both "low" values and "high" values 
having a numerator and so they both show a percentage

```{r}
df2 <- data.frame(
  ID = as.character(c(1, 1, 2, 2)),
  RANGE = factor(c("NORMAL", "LOW", "HIGH", "HIGH")),
  BL_RANGE = factor(c("NORMAL", "NORMAL", "HIGH", "HIGH")),
  ONTRTFL = c("", "Y", "", "Y"),
  stringsAsFactors = FALSE
)


df2 <- df2 %>%
  filter(ONTRTFL == "Y")

basic_table() %>%
  count_abnormal(
    var = "RANGE",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "ID", baseline = "BL_RANGE"),
    exclude_base_abn = FALSE,
    .formats = list(fraction = format_fraction)
  ) %>%
  build_table(df2)

```


The following example demonstrates the difference in outputs when using `formatters` to format the output. Here we use
`"xx / xx"` as the format. The high value does not have a numerator value and the low value does, yet both are displayed
the same way. 

```{r}
df2 <- data.frame(
  ID = as.character(c(1, 1, 2, 2)),
  RANGE = factor(c("NORMAL", "LOW", "HIGH", "LOW")),
  BL_RANGE = factor(c("NORMAL", "NORMAL", "HIGH", "HIGH")),
  ONTRTFL = c("", "Y", "", "Y"),
  stringsAsFactors = FALSE
)
df2 <- df2 %>%
  filter(ONTRTFL == "Y")

basic_table() %>%
  count_abnormal(
    var = "RANGE",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "ID", baseline = "BL_RANGE"),
    exclude_base_abn = FALSE,
    .formats = list(fraction = "xx / xx")
  ) %>%
  build_table(df2)
```
The following example demonstrates the same concept above, that when using `formatters` to format the output, all of the 
outputs will share the same format. To see the list of available formats in `formatters` see the top of the page. 

```{r}
df2 <- data.frame(
  ID = as.character(c(1, 1, 2, 2)),
  RANGE = factor(c("NORMAL", "LOW", "HIGH", "LOW")),
  BL_RANGE = factor(c("NORMAL", "NORMAL", "HIGH", "HIGH")),
  ONTRTFL = c("", "Y", "", "Y"),
  stringsAsFactors = FALSE
)
df2 <- df2 %>%
  filter(ONTRTFL == "Y")

basic_table() %>%
  count_abnormal(
    var = "RANGE",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "ID", baseline = "BL_RANGE"),
    exclude_base_abn = FALSE,
    .formats = list(fraction = "xx.x / xx.x")
  ) %>%
  build_table(df2)
```

## Creating Your Own Format Function

When creating your own format function, some important things to pay attention to are:
1. Missing values
2. 0's
3. The number of decimal places needed to be displayed 


Before creating our own format function, we will first take a look at the `format_fraction_fixed_dp` function and 
customize it after. Here we see that if the numerator value is greater than 0, the fraction and percentage is displayed. 
The percent value has 1 decimal place. If the numerator is 0, only the fraction is shown.

```{r}
# First we will see how the format_fraction_fixed_dp code works and displays the outputs
format_fraction_fixed_dp_test <- function(x, ...) {
  attr(x, "label") <- NULL
  checkmate::assert_vector(x)
  checkmate::assert_count(x["num"])
  checkmate::assert_count(x["denom"])

  result <- if (x["num"] == 0) {
    paste0(x["num"], "/", x["denom"])
  } else {
    paste0(
      x["num"], "/", x["denom"],
      " (", sprintf("%.1f", round(x["num"] / x["denom"] * 100, 1)), "%)"
    )
  }
  return(result)
}

df2 <- data.frame(
  ID = as.character(c(1, 1, 2, 2)),
  RANGE = factor(c("NORMAL", "LOW", "HIGH", "LOW")),
  BL_RANGE = factor(c("NORMAL", "NORMAL", "HIGH", "HIGH")),
  ONTRTFL = c("", "Y", "", "Y"),
  stringsAsFactors = FALSE
)
df2 <- df2 %>%
  filter(ONTRTFL == "Y")

basic_table() %>%
  count_abnormal(
    var = "RANGE",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "ID", baseline = "BL_RANGE"),
    exclude_base_abn = FALSE,
    .formats = list(fraction = format_fraction_fixed_dp_test)
  ) %>%
  build_table(df2)
```
Now we will modify this function to make it how we want. We will display 3 decimal places in the percent value and if
the numerator value is 0, will only display a 0 value. 

```{r}
# We will rename this function to custom_format
# We will add 3 decimal places by changing the %.1f to %.3f
# We will update the paste0 line under output if x["num"] = 0 conditon so that only a single 0 is displayed
custom_format <- function(x, ...) {
  attr(x, "label") <- NULL
  checkmate::assert_vector(x)
  checkmate::assert_count(x["num"])
  checkmate::assert_count(x["denom"])

  result <- if (x["num"] == 0) {
    paste0(x["num"])
  } else {
    paste0(
      x["num"], "/", x["denom"],
      " (", sprintf("%.3f", round(x["num"] / x["denom"] * 100, 1)), "%)"
    )
  }
  return(result)
}

df2 <- data.frame(
  ID = as.character(c(1, 1, 2, 2)),
  RANGE = factor(c("NORMAL", "LOW", "HIGH", "LOW")),
  BL_RANGE = factor(c("NORMAL", "NORMAL", "HIGH", "HIGH")),
  ONTRTFL = c("", "Y", "", "Y"),
  stringsAsFactors = FALSE
)
df2 <- df2 %>%
  filter(ONTRTFL == "Y")

basic_table() %>%
  count_abnormal(
    var = "RANGE",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "ID", baseline = "BL_RANGE"),
    exclude_base_abn = FALSE,
    .formats = list(fraction = custom_format) # Here we implement our new custom_format function
  ) %>%
  build_table(df2)
```

## Summary

Tern has pre-specified default format functions when generating outputs. These differ compared to `formatters` in that
we are able to set logical statements, allowing for customized formats depending on what the value is. It is possible
to create your own custom format function, just be sure to remember to implement rules on how to handle different input
values. 
