---
title: "Ideas for summarizing counts of subjects and events"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data

```{r cars}
library(dplyr)
library(tern)
library(random.cdisc.data)

adsl <- radsl(N = 10, seed = 1234, cached = FALSE)
adcm <- radcm(ADSL = adsl, seed = 1234, cached = FALSE, who_coding = TRUE)

# Add unique identifier for medications in dataset
adcm$CMID <- paste0(adcm$USUBJID, "@", adcm$CMSEQ)

adae <- radae(ADSL = adsl, seed = 1234, cached = FALSE)
adae <- df_explicit_na(adae)
```

## Table

The goal is to come up with a way to produce a summary like the one below based on two input variables - one variable for the number of subjects and another variable for the number of unique events. The challenge is the need to split the layout because we cannot have repeated `summarize_num_patients` within the same level of a layout (because this functon creates content rows).

```{r table}

t1 <- basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = "unique",
    .labels = c(
      unique = "Total number of patients with at least one treatment"
    )
  ) %>%
  build_table(adcm, alt_counts_df = adsl)

t2 <- basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  summarize_num_patients(
    var = "CMID",
    .stats = c("unique_count"),
    .labels = c(
      unique_count = "Total number of treatments"
    )
  ) %>%
  build_table(adcm, alt_counts_df = adsl)

# Combine tables.
col_info(t1) <- col_info(t2)
result <- rbind(
  t1,
  t2
)
result
```

The approach above works but it is not scalable. For example, it would be difficutl to insert this summary inside each level of a nested split like so:

```{r nested_table}
basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  split_rows_by(
    "ATC2",
    child_labels = "visible",
    nested = FALSE,
    indent_mod = -1L,
    split_fun = drop_split_levels
  ) %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = c("unique", "nonunique"),
    .labels = c(
      unique = "Total number of patients with at least one treatment",
      nonunique = "Total number of treatments"
    )
  ) %>%
  build_table(
    df = adcm,
    alt_counts_df = adsl
  )
```

## Ideas
1. Refactor `summarize_num_patients` as a wrapper for `analyze` instead of `summarize_row_groups`
1. Add function wrapper for `analyze` to count unique values and use it along with `summarize_num_patients`.
1. Add new function that counts unique subjects and events
1. In TLG-C examples, write adhoc function for analysis

### Refactor `summarize_num_patients` as wrapper for `analyze`
```{r, idea_1}

summarize_num_patients2 <- function(lyt,
                                    vars,
                                    .stats = NULL,
                                    .formats = NULL,
                                    .labels = NULL,
                                    ...) {
  afun <- make_afun(
    tern:::c_num_patients,
    .stats = .stats,
    .formats = .formats,
    .labels = .labels
  )

  analyze(
    lyt = lyt,
    vars = vars,
    afun = afun,
    extra_args = list(...),
    show_labels = "hidden" # NOTE: this approach won't work without hiding the labels.
  )
}
```

The benefits of this approach are minimal impact for users already used to working with this function. However, the big negative is that with the loss of content rows, sorting and trimming functionality is also lost.

```{r, table_1}

result <- basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  add_overall_col("All") %>%
  summarize_num_patients2(
    vars = "USUBJID",
    .stats = "unique",
    .labels = c(
      unique = "Total number of patients with at least one treatment"
    )
  ) %>%
  summarize_num_patients2(
    vars = "CMID",
    .stats = c("unique_count"),
    .labels = c(
      unique_count = "Total number of treatments"
    )
  ) %>%
  split_rows_by(
    "ATC2",
    child_labels = "visible",
    nested = FALSE,
    indent_mod = -1L,
    split_fun = drop_split_levels
  ) %>%
  summarize_num_patients2(
    vars = "USUBJID",
    .stats = "unique",
    .labels = c(
      unique = "Total number of patients with at least one treatment"
    )
  ) %>%
  summarize_num_patients2(
    vars = "CMID",
    .stats = c("unique_count"),
    .labels = c(
      unique_count = "Total number of treatments"
    )
  ) %>%
  build_table(adcm, alt_counts_df = adsl)

result
```

### New tern function: `analyze_num_patients`

Adding this function is not too hard and we can reuse some existing Statistics functions. However the overlap in functionality with `summarize_num_patients` can be confusing to users not familiar with `rtables`.
```{r, idea_2}

analyze_num_patients <- function(lyt,
                                 vars,
                                 .stats = NULL,
                                 .formats = NULL,
                                 .labels = NULL,
                                 .indent_mods = NULL,
                                 show_labels = "default",
                                 ...) {
  afun <- make_afun(
    tern:::c_num_patients,
    .stats = .stats,
    .formats = .formats,
    .labels = .labels,
    .indent_mods = .indent_mods
  )

  analyze(
    lyt = lyt,
    vars = vars,
    afun = afun,
    extra_args = list(...),
    show_labels = show_labels
  )
}
```

```{r, table_2}

basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = "unique",
    .labels = c(
      unique = "Total number of patients with at least one treatment"
    )
  ) %>%
  analyze_num_patients(
    vars = "CMID",
    .stats = "unique_count",
    .labels = c(unique_count = "Number of events"),
    .indent_mods = c(unique_count = -1L)
  ) %>%
  build_table(adcm, alt_counts_df = adsl)
```

Another limitation of this approach is it results in a longer layout for standard templates. There is also a need to hide labels to make the "Number of events" row look like a content row.
```{r, table_2_split}

result <- basic_table() %>%
  add_colcounts() %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = "unique",
    .labels = c(
      unique = "Total number of patients with at least one treatment"
    )
  ) %>%
  analyze_num_patients(
    vars = "CMID",
    .stats = "unique_count",
    .labels = c(unique_count = "Number of events"),
    .indent_mods = c(unique_count = -1L)
  ) %>%
  split_rows_by(
    "ATC2",
    child_labels = "visible",
    nested = FALSE,
    indent_mod = -1L,
    split_fun = drop_split_levels
  ) %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = "unique",
    .labels = c(
      unique = "Total number of patients with at least one treatment"
    )
  ) %>%
  analyze_num_patients(
    vars = "CMID",
    .stats = "unique_count",
    .labels = c(unique_count = "Number of events"),
    .indent_mods = c(unique_count = -1L),
    show_labels = "hidden"
  ) %>%
  count_occurrences(
    "CMDECOD",
    .indent_mods = c(count_fraction = -1L)
  ) %>%
  build_table(adcm, alt_counts_df = adsl)


result

result_sorted <- result %>%
  sort_at_path(path = c("ATC2"), scorefun = cont_n_onecol(1)) %>%
  sort_at_path(path = c("ATC2", "*", "CMDECOD"), scorefun = score_occurrences)

result_sorted
```

### Modify `summarize_num_patients` to return multi-line content rows for counting unique subjects and events

This approach probably makes the most sense. A new argument (e.g. `count_by`) can be added to help determine the correct counts of `unique` and `nonunique` entries. We can make `count_by = NULL` by default, so that current functionality is maintained. This approach would then have minimal impact on the entries in the TLG-C.

```{r, idea_3, eval = FALSE}

basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  new_summarize_subj_and_event(
    vars = "USUBJID",
    count_by = "CMID",
    .stats = c("unique", "nonunique"),
    .labels = c(
      unique = "Total number of patients with at least one adverse event",
      nonunique = "Total number of events"
    )
  ) %>%
  build_table(adcm, alt_counts_df = adsl)
```


### Ad-hoc function: multi-line content rows for TLG-C examples 

The ad-hoc function will return multi-line content rows with the 2 variables summarized.
```{r idea_4}

# new ad-hoc analysis function
foo <- function(df, labelstr = "", .N_col, .var, .var2) {
  result1 <- s_num_patients(
    x = df[[.var]],
    labelstr = labelstr,
    .N_col = .N_col
  )

  result2 <- s_num_patients(
    x = df[[.var2]],
    labelstr = labelstr,
    .N_col = .N_col
  )

  list(unique_subj = result1$unique, unique_events = result2$unique_count)
}

# create formatting
c_foo <- make_afun(
  foo,
  .stats = c("unique_subj", "unique_events"),
  .formats = c(unique_subj = format_count_fraction, unique_events = "xx"),
  .labels = c(
    unique_subj = "Number of patients with at least one event",
    unique_events = "Number of events"
  )
)


foo(adcm, .N_col = 10, .var = "USUBJID", .var2 = "CMID")
```

While using `summarize_row_groups` directly is OK, it does not seem very efficient to set up the custom function for each analysis. Also, not great as we would need to add ad-hoc function `cfun` in modules too.
```{r, table_4}

basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  summarize_row_groups(cfun = c_foo, extra_args = list(.var = "USUBJID", .var2 = "CMID")) %>%
  split_rows_by(
    "ATC2",
    child_labels = "visible",
    nested = FALSE,
    indent_mod = -1L,
    split_fun = drop_split_levels
  ) %>%
  summarize_row_groups(cfun = c_foo, extra_args = list(.var = "USUBJID", .var2 = "CMID")) %>%
  build_table(adcm, alt_counts_df = adsl)
```

# Analyzing Events by SMQ

This is a related issue to how the counting of patients and events is done. There are 2 main options that differ in the 
structure of the input analysis data (long vs wide):

### Transform dataset to stack events by SMQ (long analysis dataset)
Pros:
* this works and is intuitive with rtables framework
* can apply sorting

Cons:
* makes overall level statistics a bit more complicated (eg "Total number of events" not required for AET0x_SMQ, it is for CMT01B)
* Users need to handle labels.
```{r, smq_stack}
stack_df_by_smq <- function(df, smq, flag_var = "SMQ") {
  df_labels <- c(formatable::var_labels(df), "MedDRA Query")
  l_df <- lapply(smq, function(ae_grp) {
    keep <- df[[ae_grp]] != "<Missing>"
    df <- df[keep, ]
    df[[flag_var]] <- ae_grp
    df
  })

  result <- do.call(rbind, l_df)

  result[[flag_var]] <- factor(result[[flag_var]], levels = smq) # so missing levels are added
  formatable::var_labels(result) <- df_labels
  result
}

# try out helper function
adae_smq1 <- stack_df_by_smq(adae, c("SMQ01NAM", "SMQ02NAM", "CQ01NAM"))
adae_smq1 %>% count(SMQ)

tbl <- basic_table() %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = c("unique"),
    .labels = c(
      unique = "Total number of patients with at least one adverse event"
    )
  ) %>%
  split_rows_by("SMQ", child_labels = "visible", indent_mod = -1L) %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = c("unique", "nonunique"),
    .labels = c(
      unique = "Total number of patients with at least one adverse event",
      nonunique = "Total number of events"
    )
  ) %>%
  build_table(adae_smq1)

tbl <- tbl %>%
  sort_at_path(
    path = c("SMQ"),
    scorefun = cont_n_onecol(1),
    decreasing = FALSE
  )

tbl
```


### Wrapper for `split_rows_by` (wide analysis dataset)

This set of repeated statements can get the right table layout by SMQ:
```{r, split_wrapper, eval = FALSE}
basic_table() %>%
  split_rows_by("SMQ1", split_fun = keep_split_levels(only = "Y")) %>%
  analyze("event") %>%
  split_rows_by("SMQ2", split_fun = keep_split_levels(only = "Y")) %>%
  analyze("event") %>%
  ...()
split_rows_by("SMQn", split_fun = keep_split_levels(only = "Y")) %>%
  analyze("event") %>%
  build_table(ANL)
```

If a wrapper is added in tern, the layout function can be nicely condensed like so:
```{r, eval = FALSE}
basic_table() %>%
  split_rows_by_value(split_vars = c("SMQ1", "SMQ2", "SMQ3", ..., "SMQn"), keep = "Y") %>%
  analyze("event") %>%
  build_table(ANL)
```

However a big negative is that users are not able to sort the table by SMQ with `sort_at_path` so this option is out.
```{r, split_sorting}

basic_table() %>%
  split_rows_by("SMQ01NAM", split_fun = remove_split_levels("<Missing>"), visible_label = TRUE, nested = FALSE) %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = c("unique", "nonunique"),
    .labels = c(
      unique = "Total number of patients with at least one adverse event",
      nonunique = "Total number of events"
    )
  ) %>%
  split_rows_by("CQ01NAM", split_fun = remove_split_levels("<Missing>"), visible_label = TRUE, nested = FALSE) %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = c("unique", "nonunique"),
    .labels = c(
      unique = "Total number of patients with at least one adverse event",
      nonunique = "Total number of events"
    )
  ) %>%
  build_table(adae)
```

### One more consideration for SMQ analyses
In `RMPT06`, users need to interleave results from ADSL (eg "90% CI for patients with AEs") and ADAE (eg "Number of serious AEs") by SMQ.

Even if interleaving nodes is added as a [feature](https://github.com/Roche/rtables/issues/162) in `rtables`, it's not intuitive to stack ADSL by SMQ given that all the flag variables are in ADAE. To follow this approach users would need to:

* In  ADSL:
  1. Add SMQs to ADSL
  2. Transform ADSL to stack it by SMQ
  3. Create the layout.

* In ADAE:
  1. Transform ADAE to stack it by SMQ (exactly the same way as ADSL)
  2. Create the layout.

* Interleave the ADSL and ADAE layouts.

This process seems too complex. In the future, we should explore how to base the analysis only on ADAE. This will mean adjusting layout pieces like `estimate_proportion` to perhaps accept an argument like `count_by`.

```{r, rmpt06, eval = FALSE}
# Code below uses current approach of creating layouts for ADSL and ADAE separately.
# When it comes to scaling this approach for multiple SMQs, it will not be sufficient.

lyt_adsl <- basic_table() %>%
  split_cols_by("ACTARM") %>%
  add_colcounts() %>%
  estimate_proportion(
    vars = "AEFL",
    method = "clopper-pearson",
    .labels = c(
      n_prop = "Number of patients with at least one adverse event",
      prop_ci = "95% CI for % of patients with at least one AE (Clopper-Pearson)"
    ),
    table_names = "est_prop"
  )

# Layout for variables from adae dataset.
lyt_adae <- basic_table() %>%
  split_cols_by("ACTARM") %>%
  add_colcounts() %>%
  count_values(
    "STUDYID",
    values = "AB12345",
    .stats = "count",
    .labels = c(count = "Total number of AEs"),
    table_names = "total_aes"
  ) %>%
  count_occurrences("WTOXGR", .indent_mods = 1L) %>%
  count_patients_with_flags(
    "USUBJID",
    flag_variables = formatable::var_labels(adae[, "fl_ser"])
  ) %>%
  count_occurrences("AEOUT", denom = "n", .indent_mods = 1L)
```

