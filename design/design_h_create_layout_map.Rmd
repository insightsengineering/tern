---
title: "Design for helper function to create layout map"
author: "Rosemary Li"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of LBT04}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

Configuration
=============

```{r setup}
library(rtables)
library(tern)
library(dplyr)
library(assertthat)

packageVersion("tern")
packageVersion("rtables")
```

Introduction
=============

When templates like LBT04, VST02, EGT02, LBT15 et al were refactored using `trim_levels_to_map`, how to define the map
correctly is critical. Different templates have different scenarios to create the map. For example
- VST02/ECGT02 have both directions
- LBT04 follow the rule that at least one observation with ANRLO > 0 for low direction and at least one observation with ANRHI is not missing for high direction.
- LBT15 map is created from metadata.

Design
=============

Maybe the function can get different `method` so that map for different templates can be created accordingly.

```{r}
h_map_with_count_abnormal <- function(
  df,
  split_rows_varibles,
  anl_variable,
  abnormal = list(low = c("LOW", "LOW LOW"), high = c("HIGH", "HIGH HIGH")),
  method = c("default", "both", "lbt04"),
  na_level = "<Missing>"
) {
  assert_that(
    is.string(anl_variable),
    is_df_with_variables(df, list(val = split_rows_varibles, anl = anl_variable)),
    is_character_list(abnormal, min_length = 2, max_length = 2),
    is_df_with_factors(df, list(val = anl_variable))
  )
  method <- match.arg(method)

  # drop unused levels
  df <- droplevels(df)

  normal_value <- setdiff(levels(df[[anl_variable]]), unlist(abnormal))
  assert_that(
    length(normal_value) == 1
  )

  # default method will only have what is observed in the df, and records with all normals will be excluded to avoind
  # error in rtable building.
  if (method == "default") {
    df_abnormal <- subset(df, df[[anl_variable]] %in% unlist(abnormal))
    map <- unique(df_abnormal[c(split_rows_varibles, anl_variable)])
    map_normal <- unique(map[, split_rows_varibles])
    map_normal[[anl_variable]] <- normal_value
    map <- rbind(map, map_normal)
    map <- data.frame(lapply(map, as.character), stringsAsFactors = FALSE)
  } else if (method == "both") { 
    # both method will have both directions for all observed PARAMs like in VST02ÃŸ
    map <- unique(df[split_rows_varibles])
    anl_variable_levels <- unname(append(unlist(abnormal), normal_value))
    anl_variable_df <- as.data.frame(anl_variable_levels)
    colnames(anl_variable_df) <- anl_variable
    anl_variable_df <- do.call("rbind", replicate(nrow(map), anl_variable_df, simplify = FALSE))
    map <- map[rep(seq_len(nrow(map)), each = length(anl_variable_levels)), ]
    map <- cbind(map, anl_variable_df)
    map <- data.frame(lapply(map, as.character), stringsAsFactors = FALSE)
  } else if (method == "lbt04") { 
    #lbt04 method follows the rule that at least one observation with ANRLO > 0 for low 
    #direction and at least one observation with ANRHI is not missing for high direction.
    assert_that(
      is_df_with_variables(df, list(low = "ANRLO", high = "ANRHI"))
      # might need some assert that abnormal should have low and high direction
    )

    df_low <- subset(df, df[["ANRLO"]] > 0)
    map_low <- unique(df_low[split_rows_varibles])
    low_levels <- unname(unlist(abnormal[toupper(names(abnormal)) == "LOW"]))
    low_levels_df <- as.data.frame(low_levels)
    colnames(low_levels_df) <- anl_variable
    low_levels_df <- do.call("rbind", replicate(nrow(map_low), low_levels_df, simplify = FALSE))
    map_low <- map_low[rep(seq_len(nrow(map_low)), each = length(low_levels)), ]
    map_low <- cbind(map_low, low_levels_df)

    df_high <- subset(df, df[["ANRHI"]] != na_level | !is.na(df[["ANRHI"]]))
    map_high <- unique(df_high[split_rows_varibles])
    high_levels <- unname(unlist(abnormal[toupper(names(abnormal)) == "HIGH"]))
    high_levels_df <- as.data.frame(high_levels)
    colnames(high_levels_df) <- anl_variable
    high_levels_df <- do.call("rbind", replicate(nrow(map_high), high_levels_df, simplify = FALSE))
    map_high <- map_high[rep(seq_len(nrow(map_high)), each = length(high_levels)), ]
    map_high <- cbind(map_high, high_levels_df)

    map_normal <- unique(rbind(map_low, map_high)[split_rows_varibles])
    map_normal[anl_variable] <- normal_value

    map <- rbind(map_low, map_high, map_normal)
    map <- data.frame(lapply(map, as.character), stringsAsFactors = FALSE)
  }

  map
}
```

