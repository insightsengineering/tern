---
title: "Design for helper function to create layout map in LBT04/VST02/EGT02/LBT15"
author: "Rosemary Li"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of LBT04/VST02/EGT02/LBT15}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

Configuration
=============

```{r setup}
library(rtables)
library(tern)
library(dplyr)
library(assertthat)
library(checkmate)

packageVersion("tern")
packageVersion("rtables")
```

Introduction
=============

When templates like LBT04, VST02, EGT02, LBT15 et al were refactored using `trim_levels_to_map`, how to define the map
correctly is critical. Different templates have different scenarios to create the map. For example
- VST02/ECGT02 have both directions
- LBT04 follow the rule that at least one observation with ANRLO > 0 for low direction and at least one observation with ANRHI is not missing for high direction.
- LBT15 map is created from metadata/ext_ncictc4.sas7bdat.

Design
=============

New assert functions.
@Joe, this is legacy function from last sprint, please ignore it.
```{r eval=FALSE}
is_df_with_no_na_level <- function(df, variables, na_level) {
  assertthat::assert_that(
    is_df_with_variables(df, variables),
    assertthat::is.string(na_level)
  )
  !any(df[, unlist(variables)] == na_level)
}
assertthat::on_failure(is_df_with_no_na_level) <- function(call, env) {
  paste(deparse(call$df), "contains missing data as defined by the argument na_level")
}
```


Maybe the function can get different `method` so that map for different templates can be created accordingly.
Store and use metadata.

Below codes only need to run once and then load data using `data("ext_ncictc4")`.
```{r eval=FALSE}
ext_ncictc4 <- haven::read_sas("/home/rstudio/nest_projects/tern/design/metadata/ext_ncictc4.sas7bdat")
ext_ncictc4 <- usethis::use_data(ext_ncictc4)
```

@Joe, for this one, please only focus on the method being "meta_ext_ncictc4", other two are already in production.
```{r}
h_map_with_count_abnormal <- function(
  df,
  variables = list(anl = "ANRIND", split_rows = c("LBCAT", "PARAM"), range_low = "ANRLO", range_high = "ANRHI"),
  abnormal = list(low = c("LOW", "LOW LOW"), high = c("HIGH", "HIGH HIGH")),
  method = c("default", "range", "meta_ext_ncictc4"),
  na_level = "<Missing>"
) {
  method <- match.arg(method)

  assertthat::assert_that(
    "anl" %in% names(variables),
    "split_rows" %in% names(variables),
    is_variables(variables),
    is_df_with_factors(df, list(val = variables$anl)),
    # !any(df[variables$split_rows] == na_level),
    # is_df_with_no_na_level(df, variables = list(split_rows = variables$split_rows), na_level = na_level),
    # is_factor_no_na(df[variables$split_rows]),
    # !na_level %in% df[[variables$anl]],
    is_df_with_no_na_level(df, variables = list(anl = variables$anl), na_level = na_level),
    is_factor_no_na(df[[variables$anl]])
  )
  checkmate::assert_list(abnormal, types = "character", len = 2)
  
  # drop unused levels
  df <- droplevels(df)

  normal_value <- setdiff(levels(df[[variables$anl]]), unlist(abnormal))
  assertthat::assert_that(
    length(normal_value) == 1,
    all_elements_in_ref(setdiff(levels(df[[variables$anl]]), normal_value), unlist(abnormal))
  )

  # default method will only have what is observed in the df, and records with all normals will be excluded to avoid
  # error in rtable building.
  if (method == "default") {
    assertthat::assert_that(
      is_df_with_variables(df, variables = list(anl = variables$anl, split_row = variables$split_rows))
    )
    df_abnormal <- subset(df, df[[variables$anl]] %in% unlist(abnormal))
    map <- unique(df_abnormal[c(variables$split_rows, variables$anl)])
    map_normal <- unique(subset(map, select = variables$split_rows))
    map_normal[[variables$anl]] <- normal_value
    map <- rbind(map, map_normal)
    map <- data.frame(lapply(map, as.character), stringsAsFactors = FALSE)
  } else if (method == "range") {
    #range method follows the rule that at least one observation with ANRLO > 0 for low
    #direction and at least one observation with ANRHI is not missing for high direction.
    assertthat::assert_that(
      is_df_with_variables(df, variables),
      "range_low" %in% names(variables),
      "range_high" %in% names(variables)
    )

    df_low <- subset(df, df[[variables$range_low]] > 0)
    map_low <- unique(df_low[variables$split_rows])
    low_levels <- unname(unlist(abnormal[toupper(names(abnormal)) == "LOW"]))
    low_levels_df <- as.data.frame(low_levels)
    colnames(low_levels_df) <- variables$anl
    low_levels_df <- do.call("rbind", replicate(nrow(map_low), low_levels_df, simplify = FALSE))
    map_low <- map_low[rep(seq_len(nrow(map_low)), each = length(low_levels)), ]
    map_low <- cbind(map_low, low_levels_df)

    df_high <- subset(df, df[[variables$range_high]] != na_level | !is.na(df[[variables$range_high]]))
    map_high <- unique(df_high[variables$split_rows])
    high_levels <- unname(unlist(abnormal[toupper(names(abnormal)) == "HIGH"]))
    high_levels_df <- as.data.frame(high_levels)
    colnames(high_levels_df) <- variables$anl
    high_levels_df <- do.call("rbind", replicate(nrow(map_high), high_levels_df, simplify = FALSE))
    map_high <- map_high[rep(seq_len(nrow(map_high)), each = length(high_levels)), ]
    map_high <- cbind(map_high, high_levels_df)

    map_normal <- unique(rbind(map_low, map_high)[variables$split_rows])
    map_normal[variables$anl] <- normal_value

    map <- rbind(map_low, map_high, map_normal)
    map <- data.frame(lapply(map, as.character), stringsAsFactors = FALSE)
  } else if (method == "meta_ext_ncictc4") {
    assertthat::assert_that(
      is_df_with_variables(df, variables = list(paramcd = "PARAMCD")),
      any(lengths(abnormal) < 2) # I want to make sure LOW LOW/HIGH HIGH doesn't go into abnormal for this method #nolint
    )
    data("ext_ncictc4")
    ext_ncictc4 <- ext_ncictc4[c("PARAMCD", "RESULT")]
    ext_ncictc4 <- ext_ncictc4[ext_ncictc4[["PARAMCD"]] %in% unique(df[["PARAMCD"]]), ]
    ext_ncictc4[[variables$anl]] <- na_level
    ext_ncictc4[ext_ncictc4[["RESULT"]] %in% c("1", "2", "3", "4"), ][[variables$anl]] <- abnormal$high
    ext_ncictc4[ext_ncictc4[["RESULT"]] %in% c("-1", "-2", "-3", "-4"), ][[variables$anl]] <- abnormal$low
    ext_ncictc4[ext_ncictc4[["RESULT"]] %in% c("0"), ][[variables$anl]] <- normal_value
    ext_ncictc4 <- unique(ext_ncictc4[ext_ncictc4[[variables$anl]] != na_level, ][c("PARAMCD", variables$anl)])

    #incude extra split_rows
    map <- if ("PARAMCD" %in% variables$split_rows) {
      unique(df[c(variables$split_rows)])
    } else {
      unique(df[c(variables$split_rows, "PARAMCD")])
    }
    map <- merge(map, ext_ncictc4)
    map <- map[c(variables$split_rows, variables$anl)]
    map <- data.frame(lapply(map, as.character), stringsAsFactors = FALSE)
  }

  # sort map final output
  for (i in rev(seq_len(length(variables$split_rows)))) {
    map <- map[order(map[[i]]), ]
  }
  map
}
```

Unit tests
=============
```{r eval=FALSE}
df <- data.frame(
  USUBJID = c(rep("1", 4), rep("2", 4), rep("3", 4)),
  AVISIT = c(
    rep("WEEK 1", 2), rep("WEEK 2", 2), rep("WEEK 1", 2), rep("WEEK 2", 2), rep("WEEK 1", 2), rep("WEEK 2", 2)
  ),
  PARAM = rep(c("ALT", "CPR"), 6),
  ANRIND = c("NORMAL", "NORMAL", "LOW", "HIGH", "LOW", "LOW", "HIGH", "HIGH", rep("NORMAL", 4))
)
df$ANRIND <- factor(df$ANRIND, levels = c("LOW", "HIGH", "NORMAL")) #nolint
```

```{r}
h_map_with_count_abnormal(
  df = df,
  split_rows_varibles = "PARAM",
  anl_variable = "ANRIND",
  abnormal = list(low = "LOW", high = "HIGH"),
  method = "both"
)
```
see difference between default and both
```{r}
df <- df %>% mutate(ANRIND = ifelse(PARAM == "ALT", "NORMAL", as.character(ANRIND)))
df$ANRIND <- factor(df$ANRIND, levels = c("LOW", "HIGH", "NORMAL")) #nolint
h_map_for_count_abnormal(
  df = df,
  variables = list(anl = "ANRIND", split_rows = c("PARAM")),
  abnormal = list(low = "LOW", high = "HIGH"),
  method = "default"
)
h_map_with_count_abnormal(
  df = df,
  split_rows_varibles = "PARAM",
  anl_variable = "ANRIND",
  abnormal = list(low = "LOW", high = "HIGH"),
  method = "both"
)
```

STREAM tests with LBT15
=============

test with new method and stream data for lbt15.
```{r eval=FALSE}
# ADSL and ADLB are stream source data read in with haven::read_sas()

adsl <- ADSL %>% df_explicit_na() %>% filter(SAFFL == "Y")
adlb_f <- ADLB %>% df_explicit_na() %>% filter(ONTRTFL == "Y" & ATOXGR != "<Missing>" & PARCAT2 == "SI") %>%
  mutate(ATOXGR = factor(ATOXGR, levels = c("-4", "4", "-1", "-2", "-3", "0", "1", "2", "3", "<Missing>")),
         BTOXGR = factor(BTOXGR, levels = c("-4", "4", "-1", "-2", "-3", "0", "1", "2", "3", "<Missing>")))
adlb_f <- adlb_f %>%
  mutate(
    ATOXGR_CAT = fct_collapse(ATOXGR,
                              "LOW" = c("-3", "-4"),
                              "NORMAL" = c("-2", "-1", "0", "1", "2"),
                              "HIGH" = c("3", "4")
    ),
    BTOXGR_CAT = fct_collapse(BTOXGR,
                              "LOW" = c("-3", "-4"),
                              "NORMAL" = c("-2", "-1", "0", "1", "2", "<Missing>"),
                              "HIGH" = c("3", "4")
    )
  )


map <- h_map_for_count_abnormal(
  df = adlb_f,
  variables = list(anl = "ATOXGR_CAT", split_rows = c("PARCAT1", "PARAM")),
  abnormal = list(low = c("LOW"), high = c("HIGH")),
  method = "meta_ext_ncictc4",
  na_level = "<Missing>"
)

lyt <- basic_table() %>%
  split_cols_by(var = "ARM") %>%
  add_colcounts() %>%
  split_rows_by("PARCAT1", split_fun = trim_levels_to_map(map = map)) %>%
  split_rows_by("PARAM", split_fun = trim_levels_to_map(map = map)) %>%
  count_abnormal(
    var = "ATOXGR_CAT",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "USUBJID", baseline = "BTOXGR_CAT"),
    exclude_base_abn = TRUE
  ) %>%
  append_topleft("    Direction of Abnormality")

build_table(lyt, adlb_f %>% filter(LBCAT != "<Missing>"), alt_counts_df = adsl)

# variant 2
adlb_f_2 <- adlb_f %>%
  mutate(
    ATOXGR_CAT = fct_collapse(ATOXGR,
                              "LOW" = c("-2", "-3", "-4"),
                              "NORMAL" = c("-1", "0", "1"),
                              "HIGH" = c("2", "3", "4")
    ),
    BTOXGR_CAT = fct_collapse(BTOXGR,
                              "LOW" = c("-2", "-3", "-4"),
                              "NORMAL" = c("-1", "0", "1"),
                              "HIGH" = c("2", "3", "4")
    )
  )

build_table(lyt, adlb_f_2 %>% filter(LBCAT != "<Missing>"), alt_counts_df = adsl)
```

replace stream data with scda so that knit will work
```{r}
ADLB <- haven::read_sas("../adlb.sas7bdat") %>% df_explicit_na() #nolint
adlb_f <- ADLB %>% filter(ONTRTFL == "Y" & ANRIND != "<Missing>" & PARCAT2 == "SI")

h_map_with_count_abnormal(
  df = adlb_f %>% filter(LBCAT != "<Missing>"),
  split_rows_varibles = c("LBCAT", "PARAM"),
  anl_variable = "ANRIND",
  abnormal = list(low = "LOW", high = "HIGH"),
  method = "lbt04"
)

lyt <- basic_table() %>%
  split_cols_by(var = "ARM") %>%
  add_colcounts() %>%
  split_rows_by("PARCAT1", split_fun = trim_levels_to_map(map = map)) %>%
  split_rows_by("PARAM", split_fun = trim_levels_to_map(map = map)) %>%
  count_abnormal(
    var = "ATOXGR_CAT",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "USUBJID", baseline = "BTOXGR_CAT"),
    exclude_base_abn = TRUE
  ) %>%
  append_topleft("    Direction of Abnormality")

build_table(lyt, adlb_f, alt_counts_df = adsl)

```

As discussed in the design PR #255, how should we deal with some PARAMCDs that are not in the input dataset.
```{r}
adlb_f_noALTSI <- adlb_f %>% filter(PARAMCD != "ALTSI")
build_table(lyt, adlb_f_noALTSI %>% filter(LBCAT != "<Missing>"), alt_counts_df = adsl)
```

```{r}
map_test <- h_map_for_count_abnormal(
  df = adlb_f_noALTSI,
  variables = list(anl = "ATOXGR_CAT", split_rows = c("PARCAT1", "PARAM")),
  abnormal = list(low = c("LOW"), high = c("HIGH")),
  method = "meta_ext_ncictc4",
  na_level = "<Missing>"
)

lyt_test <- basic_table() %>%
  split_cols_by(var = "ARM") %>%
  add_colcounts() %>%
  split_rows_by("PARCAT1", split_fun = trim_levels_to_map(map = map_test)) %>%
  split_rows_by("PARAM", split_fun = trim_levels_to_map(map = map_test)) %>%
  count_abnormal(
    var = "ATOXGR_CAT",
    abnormal = list(low = "LOW", high = "HIGH"),
    variables = list(id = "USUBJID", baseline = "BTOXGR_CAT"),
    exclude_base_abn = TRUE
  ) %>%
  append_topleft("    Direction of Abnormality")

build_table(lyt_test, adlb_f_noALTSI %>% filter(LBCAT != "<Missing>"), alt_counts_df = adsl)
```
