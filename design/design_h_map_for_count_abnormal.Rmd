---
title: "Design for helper function to create layout map"
author: "Rosemary Li"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of LBT04}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

Configuration
=============

```{r setup}
library(rtables)
library(tern)
library(dplyr)
library(assertthat)

packageVersion("tern")
packageVersion("rtables")
```

Introduction
=============

When templates like LBT04, VST02, EGT02, LBT15 et al were refactored using `trim_levels_to_map`, how to define the map
correctly is critical. Different templates have different scenarios to create the map. For example
- VST02/ECGT02 have both directions
- LBT04 follow the rule that at least one observation with ANRLO > 0 for low direction and at least one observation with ANRHI is not missing for high direction.
- LBT15 map is created from metadata.

Design
=============

New assert functions
```{r}
is_df_with_no_na_level <- function(df, variables, na_level) {
  assert_that(
    is_df_with_variables(df, variables),
    is.string(na_level)
  )
  !any(df[, unlist(variables)] == na_level)
}
on_failure(is_df_with_no_na_level) <- function(call, env) {
  paste(deparse(call$df), "contains missing data as defined by the argument na_level")
}
```


Maybe the function can get different `method` so that map for different templates can be created accordingly.

```{r}
h_map_with_count_abnormal <- function(
  df,
  variables = list(anl = "ANRIND", split_rows = c("LBCAT", "PARAM"), range_low = "ANRLO", range_high = "ANRHI"),
  abnormal = list(low = c("LOW", "LOW LOW"), high = c("HIGH", "HIGH HIGH")),
  method = c("default", "range"),
  na_level = "<Missing>"
) {
  method <- match.arg(method)

  assert_that(
    "anl" %in% names(variables),
    "split_rows" %in% names(variables),
    is_variables(variables),
    utils.nest:::is_character_list(abnormal, min_length = 2, max_length = 2),
    is_df_with_factors(df, list(val = variables$anl)),
    # !any(df[[variables$split_rows]] == na_level),
    is_df_with_no_na_level(df, variables = list(split_rows = variables$split_rows), na_level = na_level),
    is_factor_no_na(as.factor(df[[variables$split_rows]])),
    # !na_level %in% df[[variables$anl]],
    is_df_with_no_na_level(df, variables = list(anl = variables$anl), na_level = na_level),
    is_factor_no_na(df[[variables$anl]])
  )

  # drop unused levels
  df <- droplevels(df)

  normal_value <- setdiff(levels(df[[variables$anl]]), unlist(abnormal))
  assert_that(
    length(normal_value) == 1,
    all_elements_in_ref(setdiff(levels(df[[variables$anl]]), normal_value), unlist(abnormal))
  )

  # default method will only have what is observed in the df, and records with all normals will be excluded to avoid
  # error in rtable building.
  if (method == "default") {
    assert_that(
      is_df_with_variables(df, variables = list(anl = variables$anl, split_row = variables$split_rows))
    )
    df_abnormal <- subset(df, df[[variables$anl]] %in% unlist(abnormal))
    map <- unique(df_abnormal[c(variables$split_rows, variables$anl)])
    map_normal <- unique(subset(map, select = variables$split_rows))
    map_normal[[variables$anl]] <- normal_value
    map <- rbind(map, map_normal)
    map <- data.frame(lapply(map, as.character), stringsAsFactors = FALSE)
  } else if (method == "range") {
    #range method follows the rule that at least one observation with ANRLO > 0 for low
    #direction and at least one observation with ANRHI is not missing for high direction.
    assert_that(
      is_df_with_variables(df, variables),
      "range_low" %in% names(variables),
      "range_high" %in% names(variables)
    )

    df_low <- subset(df, df[[variables$range_low]] > 0)
    map_low <- unique(df_low[variables$split_rows])
    low_levels <- unname(unlist(abnormal[toupper(names(abnormal)) == "LOW"]))
    low_levels_df <- as.data.frame(low_levels)
    colnames(low_levels_df) <- variables$anl
    low_levels_df <- do.call("rbind", replicate(nrow(map_low), low_levels_df, simplify = FALSE))
    map_low <- map_low[rep(seq_len(nrow(map_low)), each = length(low_levels)), ]
    map_low <- cbind(map_low, low_levels_df)

    df_high <- subset(df, df[[variables$range_high]] != na_level | !is.na(df[[variables$range_high]]))
    map_high <- unique(df_high[variables$split_rows])
    high_levels <- unname(unlist(abnormal[toupper(names(abnormal)) == "HIGH"]))
    high_levels_df <- as.data.frame(high_levels)
    colnames(high_levels_df) <- variables$anl
    high_levels_df <- do.call("rbind", replicate(nrow(map_high), high_levels_df, simplify = FALSE))
    map_high <- map_high[rep(seq_len(nrow(map_high)), each = length(high_levels)), ]
    map_high <- cbind(map_high, high_levels_df)

    map_normal <- unique(rbind(map_low, map_high)[variables$split_rows])
    map_normal[variables$anl] <- normal_value

    map <- rbind(map_low, map_high, map_normal)
    map <- data.frame(lapply(map, as.character), stringsAsFactors = FALSE)
  }

  # sort map final output
  for (i in rev(seq_len(length(variables$split_rows)))) {
    map <- map[order(map[[i]]), ]
  }
  map
}
```

Unit tests
=============
```{r}
df <- data.frame(
  USUBJID = c(rep("1", 4), rep("2", 4), rep("3", 4)),
  AVISIT = c(
    rep("WEEK 1", 2), rep("WEEK 2", 2), rep("WEEK 1", 2), rep("WEEK 2", 2), rep("WEEK 1", 2), rep("WEEK 2", 2)
  ),
  PARAM = rep(c("ALT", "CPR"), 6),
  ANRIND = c("NORMAL", "NORMAL", "LOW", "HIGH", "LOW", "LOW", "HIGH", "HIGH", rep("NORMAL", 4))
)
df$ANRIND <- factor(df$ANRIND, levels = c("LOW", "HIGH", "NORMAL")) #nolint
```

```{r}
h_map_with_count_abnormal(
  df = df,
  variables = list(anl = "ANRIND", split_rows = c("PARAM")),
  abnormal = list(low = "LOW", high = "HIGH"),
  method = "default"
)
```
see difference between default and both
```{r}
df <- df %>% mutate(ANRIND = ifelse(PARAM == "ALT", "NORMAL", as.character(ANRIND)))
df$ANRIND <- factor(df$ANRIND, levels = c("LOW", "HIGH", "NORMAL")) #nolint
h_map_with_count_abnormal(
  df = df,
  variables = list(anl = "ANRIND", split_rows = c("PARAM")),
  abnormal = list(low = "LOW", high = "HIGH"),
  method = "default"
)

# I think we can test this in production? 
# h_map_with_count_abnormal(
#   df = df,
#   variables = list(anl = "ANRIND", split_rows = c("PARAM")),
#   abnormal = list(low = "LOW", high = "HIGH"),
#   method = "range"
# )
```

For lbt04, use stream real data to test
```{r}
ADLB <- haven::read_sas("/home/rstudio/nest_projects/data/adlb.sas7bdat") %>% df_explicit_na() #nolint
adlb_f <- ADLB %>% filter(ONTRTFL == "Y" & ANRIND != "<Missing>" & PARCAT2 == "SI")

h_map_with_count_abnormal(
  df = adlb_f %>% filter(LBCAT != "<Missing>"),
  variables = list(anl = "ANRIND", split_rows = c("LBCAT")),
  abnormal = list(low = "LOW", high = "HIGH"),
  method = "default"
)
```

