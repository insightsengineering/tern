---
title: "Design: Cox regression (RSPT01)"
author: "Francois Collin"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of COXT01}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

Introduction
============

+ GDSR [@Hughes2020a]

Four examples to produce:

1. Cox Regression
2. Cox Regression (with Interaction Term)
3. Cox Regression (specifying covariates)
4. Cox Regression (setting strata, ties, and alpha level)

Not covered yet:

- add interaction terms and strata
- set ties
- specify covariate levels

Configuration
=============

```{r setup, eval = TRUE}
library(survival)
library(tern)
library(rtables)
library(assertthat)

packageVersion("tern")
packageVersion("rtables")
```


Prototype
=========

The `rtables` takes as an input a data frame, the intersection of a row
and a column delimits a data frame subset. The calculation based on the
whole dataframe is not yet possible within the pipeline. Therefore, the
prototype is based on two steps:

1. generation of a result data frame.
2. display the results *via* `rtables` pipeline.


Data frame: univariate Cox regression {.tabset .tabset-pills}
-------------------------------------

The function `h_coxuniv()` host the calls and calculation. It depends on
helper function `h_coxph_formulas()` to generate the list of models to fit and
`h_coxuniv_extract()` to extract and tabulate the results.


### Main worker: `h_coxuniv()`


```{r ref.label = c("control_coxuniv", "h_coxph_formulas", "h_coxuniv_extract"), results = "hide", echo = FALSE, eval = TRUE}
```

* `pval_method`, `ties`, `conf_level` are passed via `control`.
* during production: `tern:::labels_or_names` replaced by `labels_or_names`.

```{r h_coxuniv}
#' Univariate Cox Regression
#'
#' Coordinate the comparison between univariate Cox regressions.
#'
h_coxuniv <- function(variables,
                      data,
                      control = control_coxuniv()) {
  assert_that(
    is.character(variables$covariates),
    is_variables(variables[c("arm", "event", "time")]),
    is_df_with_variables(data, as.list(unlist(variables)))
  )

  vars <- c(variables$arm, variables$covariates)

  forms <- h_coxuniv_formulas(variables, interaction = control$interaction)
  mod <- lapply(
    forms, function(x) {
      coxph(formula = as.formula(x), data = data, ties = control$ties)
    }
  )
  result <- lapply(X = mod, FUN = h_coxuniv_extract, control = control)
  result <- do.call(rbind, result)
  result <- cbind(
    data.frame(
      mod = c("Treatment", rep("Covariate", length(variables$covariates))),
      term = vars,
      stringsAsFactors = FALSE
    ),
    result
  )

  # Because `label` attribute from initial dataframe needs to be used for
  # row labelling in `rtables`.
  rownames(result) <- tern:::labels_or_names(data[vars])
  attr(result, "conf_level") <- control$conf_level
  result
}
#'
#' @examples
#'
dta_test <- data.frame(
  time = c(4, 3, 1, 1, 2, 2, 3), status = c(1, 1, 1, 0, 1, 1, 0),
  x = c(0, 2, 1, 1, 1, 0, 0), y = c(0, 2, 4, 4, 1, 0, 0),
  armcd = factor(c(0, 0, 0, 0, 1, 1, 1))
)
dta_test <- h_coxuniv(
  variables = list(
    time = "time", event = "status", arm = "armcd",
    covariates = c("x", "y")
  ),
  data = dta_test,
  control = control_coxuniv(conf_level = 0.91)
)
str(dta_test)
```


### `h_coxph_formulas()`

```{r h_coxph_formulas, eval = FALSE}
#' Survival Formulas for Cox Univariate
#'
#' Create a list of survival formulas for univariate comparisons.
#'
h_coxuniv_formulas <- function(variables,
                               interaction = FALSE) {
  assert_that(
    is.character(variables$covariates),
    is_variables(variables[c("arm", "event", "time")]),
    is.flag(interaction)
  )

  ref <- paste(
    "Surv(", variables$time, ",", variables$event, ") ~ ", variables$arm
  )

  covar <- paste(
    ref,
    ifelse(interaction, "*", "+"),
    variables$covariates,
    ifelse(
      !is.null(variables$strata),
      paste("+ strata(", variables$strata, ")"),
      ""
    )
  )

  setNames(obj = c(ref, covar), nm = c("ref", variables$covariates))
}
```

```{r h_coxph_formulas_example}
#'
#' @examples
#'
h_coxuniv_formulas(
  variables = list(time = "time", event = "status", arm = "armcd",
  covariates = c("X", "y"))
)

h_coxuniv_formulas(
  variables = list(time = "time", event = "status", arm = "armcd",
  covariates = c("X", "y"), strata = "SITE")
)

h_coxuniv_formulas(
  variables = list(time = "time", event = "status", arm = "armcd",
  covariates = c("X", "y"), strata = "SITE"), interaction = TRUE
)
```

### `h_coxuniv_extract()`

* `control_coxuniv` is based on `control_coxph`, the only difference
is about the p.value method are `log-rank` is not valid here.

```{r control_coxuniv}
control_coxuniv <- function(pval_method = c("wald", "likelihood"),
                            ties = c("efron", "breslow", "exact"),
                            conf_level = 0.95,
                            interaction = FALSE) {
  pval_method <- match.arg(pval_method)
  ties <- match.arg(ties)
  assert_that(
    is_proportion(conf_level),
    is.flag(interaction)
    )

  list(
    pval_method = pval_method,
    ties = ties,
    conf_level = conf_level,
    interaction = interaction
  )
}

#' @examples
control_coxuniv()
```

* I have realized I abuse of `switch`, replaced by a simple named vector.
* `pval_method` and `conf_level` are passed via `control`.

```{r h_coxuniv_extract, eval = FALSE}
#' Tabulation of Univariate Cox Regressions
#'
#' Tabulate the result of a Cox regression model.
#'
h_coxuniv_extract <- function(mod,
                              control = control_coxuniv(),
                              effect = "armcd") {
  assert_that(
    class(mod) == "coxph",
    is.string(effect)
  )

  mod_aov <- car::Anova(
    mod,
    test.statistic = c(wald = "Wald", likelihood = "LR")[control$pval_method],
    type = "III"
  )

  # Because the number of columns and rows depends on the number of effect
  # and pval method.
  effect_aov <- mod_aov[effect, , drop = TRUE]
  pval <- rev(effect_aov)[1]
  pval <- pval[[1]]

  effect_name <- paste0(effect, 1)
  msum <- summary(mod, conf.int = control$conf_level)
  confint <- msum$conf.int[effect_name, -1]

  list(
    n = mod$n,
    hr = unname(confint["exp(-coef)"]),
    ci = unname(confint[grep("(?:lower|upper)", names(confint))]),
    pval = pval
  )
}
#'
#' @examples
# Simple test data set.
dta_test <- list(
  time = c(4, 3, 1, 1, 2, 2, 3), status = c(1, 1, 1, 0, 1, 1, 0),
  x = c(0, 2, 1, 1, 1, 0, 0), armcd = factor(c(0, 0, 0, 0, 1, 1, 1))
)
mod <- coxph(formula = Surv(time, status) ~ armcd, data = dta_test)
h_coxuniv_extract(mod)
# nolint start
# # Chunck kept aside for comparison <out of production scope>.
# pval_cox <- switch(
#   pval_method,
#   wald = summary(l_mod[[1]])$waldtest["pvalue"],
#   likelihood = summary(l_mod[[1]])$logtest["pvalue"]
# )
# nolint end
```


Render the results
------------------

```{r s_coxreg}
#' @describeIn cox_univariate statistics function.
#' @export
#' @note Not much calculation is done here, it rather prepare the data to
#'  be used by the layout creating function.
s_coxreg <- function(df, .var) {

  assert_that(
    is_df_with_variables(df, list(term = "term", var = .var)),
    is_character_or_factor(df$term)
  )

  y <- setNames(
    list(split(df[, .var, drop = FALSE], f = df$term)),
    .var
  )

  y[[.var]] <- lapply(
    X = y[[.var]],
    FUN = function(x) with_label(unlist(x), rownames(x))
  )

  y
}

#'
#' @examples
#'
dta_test <- data.frame(
  time = c(4, 3, 1, 1, 2, 2, 3), status = c(1, 1, 1, 0, 1, 1, 0),
  x = c(0, 2, 1, 1, 1, 0, 0), y = c(0, 2, 4, 4, 1, 0, 0),
  armcd = factor(c(0, 0, 0, 0, 1, 1, 1))
)
df <- h_coxuniv(
  variables = list(
    time = "time", event = "status", arm = "armcd",
    covariates = c("x", "y")
  ), data = dta_test
)
s_coxreg(df = subset(df, mod == "Covariate"), .var = "hr")

```

```{r fit_coxreg, results = "hide"}
#' @describeIn cox_univariate layout creating function.
#' @export
#'
fit_coxreg <- function(lyt, conf_level) {
  afun <- tern:::format_wrap_df(
    sfun = s_coxreg,
    formats = c(
      n = "xx", hr = "xx.xx", ci = "(xx.xx, xx.xx)", pval = "x.xxxx | (<0.0001)"
    ),
    indent_mods = c(n = 0L, hr = 0L, ci = 0L, pval = 0L)
  )
  split_cols_by_multivar(
    lyt = lyt, c("n", "hr", "ci", "pval"),
    varlabels = c("n", "HR", paste0(100 * conf_level, "% CI"), "p.value")
  ) %>%
    analyze_colvars(afun = afun)
}
#'
#' @examples
#'
dta_test <- data.frame(
  time = c(4, 3, 1, 1, 2, 2, 3), status = c(1, 1, 1, 0, 1, 1, 0),
  x = c(0, 2, 1, 1, 1, 0, 0), y = c(0, 2, 4, 4, 1, 0, 0),
  armcd = factor(c(0, 0, 0, 0, 1, 1, 1))
)
attr(dta_test$x, "label") <- "That is an X lab"
dta_test <- h_coxuniv(
  variables = list(
    time = "time", event = "status", arm = "armcd",
    covariates = c("x", "y")
  ),
  data = dta_test,
  control = control_coxuniv(conf_level = 0.91)
)
result <- split_rows_by(lyt = NULL, "mod", child_labels = "visible") %>%
  fit_coxreg(conf_level = attr(dta_test, "conf_level")) %>%
  build_table(df = dta_test)

result
```

```{r, echo = FALSE}
as_html(result)
```


```{r fit_coxreg_test}
library(testthat)
result_matrix <- to_string_matrix(result)

expected_matrix <- structure(
  c(
    "", "Treatment", "armcd", "Covariate", "That is an X lab",
    "y", "n", "", "7", "", "7", "7", "HR", "", "0.87", "", "0.39",
    "0.04", "91% CI", "", "(0.2, 6.51)", "", "(0.23, 27.69)", "(0.43, 1517.85)",
    "p.value", "", "0.8878", "", "0.5072", "0.1785"
  ), .Dim = 6:5
)

expect_identical(result_matrix, expected_matrix)
```



References
==========
