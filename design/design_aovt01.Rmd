---
title: "Design: AOVT01"
author: "Nina Qi"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    number_sections: true
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of AOVT01}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dev = "svg"
)
```

Summary
=======

Targets:

- test candidate design as AOVT01

Plan:

- [ ] helper function `h_ancova`
- [ ] low level summary function `s_ancova`
- [ ] high level function `summarize_ancova`


Configuration
=============

Dependencies:

```{r setup, message=FALSE}
library(random.cdisc.data)
library(rtables)
library(dplyr)
library(tern)
library(assertthat)

packageVersion("tern")
packageVersion("rtables")
```

Data
=============

```{r data}
adsl <- radsl(cached = TRUE)
adqs <- radqs(cached = TRUE)

adqs_single <- adqs %>%
  filter(
    AVISIT == "WEEK 1 DAY 8",  # single time point
    PARAMCD == "FKSI-FWB"  # single end point
  ) %>%
  mutate(CHG = ifelse(BMEASIFL == "Y", CHG, NA))  # only analyze evaluable population

adqs_multi <- filter(adqs, AVISIT == "WEEK 1 DAY 8")
```

Design
=============

## Functions {.tabset .tabset-pills}
Some special considerations:

* Should we pass formula directly, or variable names such as `.var`, `covariates`, etc.
  + new structure prefers that we do not pass a formula
  + one approach is to pass in covariates as string, etc. `"covariates = AGE * SEX"`, etc.
  + to assemble the formula, would then need the `split_cols_by` variable name to be passed. `df$col_split_variable` seems to be not working, so in the design doc, temporarily using `arm` instead of the `col_split_variable`.


* In ANCOVA analysis, the data overall with all arms needs to be fit into the model together, which is different from standard approach in `rtables`. `.df_row` has been be added into `rtables`, and a PR has been submitted for it to work with `format_wrap_df`.


* Currently `s_ancova` as one function is applicable for both reference and treatment arms, where model only needs to run once. Is there a need to separate to 2 function, one for estimated marginal mean summary (not considering `.in_ref_col`), and the other for comparison.

* Will work on documentation

### Statistics Helper Functions
```{r}
#' Summary for analysis of covariance (ANCOVA).
#'
#' Summarize results of ANCOVA. This can be used to analyze multiple endpoints and/or
#' multiple timepoints within the same response variable.
#'
#' @template formatting_arguments
#'
#' @name summarize_ancova
#'
NULL

#' @describeIn summarize_ancova Helpfer function to return results of a linear model
#'
h_ancova <- function(.var,
                     .df_row,
                     variables) {

  assertthat::assert_that(
    assertthat::is.string(.var),
    is.list(variables),
    all(names(variables) %in% c("arm", "covariates"))
  )

  arm <- variables$arm
  covariates <- variables$covariates
  covariates_part <- paste(covariates, collapse = " + ")

  if (covariates_part != "") {
    formula <- as.formula(paste0(.var, " ~ ", covariates_part, " + ", arm))
  } else {
    formula <- as.formula(paste0(.var, " ~ ", arm))
  }

  lm_fit <- stats::lm(
    formula = formula,
    data = .df_row
  )

  emmeans_fit <- emmeans::emmeans(
    lm_fit,
    # Specify here the group variable over which EMM are desired.
    specs = arm,
    # Pass the data again so that the factor levels of the arm variable can be inferred.
    data = .df_row
  )

  emmeans_fit
}


```

### Statistics Functions
```{r, s_fun}
#' df <- adqs_single %>% dplyr::filter(ARMCD == "ARM B")
#' .df_row <- adqs_single
#' .var <- "CHG"
#' arm <- "ARMCD"
#' covariates <- "SEX * AGE"
#' conf_level <- 0.95
#' s_ancova(df, .var, .df_row, variables, .in_ref_col = FALSE, conf_level = conf_level)
s_ancova <- function(df,
                     .var,
                     .df_row,
                     variables,
                     .in_ref_col,
                     conf_level) {

  emmeans_fit <- h_ancova(.var = .var, .df_row = .df_row, variables = variables)

  sum_fit <- summary(
    emmeans_fit,
    level = conf_level
  )

  arm <- variables$arm

  y <- df[[.var]]
  sum_level <- unique(df[[arm]])
  # Ensure that there is only one element in sum_level.
  assertthat::assert_that(
    assertthat::is.scalar(sum_level)
  )
  sum_fit_level <- sum_fit[sum_fit[[arm]] == sum_level, ]

  if (.in_ref_col) {
    list(
      n = length(y[!is.na(y)]),
      lsmean = with_label(sum_fit_level$emmean, "Adjusted Mean"),
      lsmean_diff = with_label("", "Difference in Adjusted Means"),
      lsmean_diff_ci = with_label("", tern:::f_conf_level(conf_level)),
      pval = with_label("", "p-value")
    )
  } else {
    # Estimate the differences between the marginal means.
    emmeans_contrasts <- emmeans::contrast(
      emmeans_fit,
      # Compare all arms versus the control arm.
      method = "trt.vs.ctrl",
      # Take the first level of the arm factor as the control arm.
      ref = 1
    )
    sum_contrasts <- summary(
      emmeans_contrasts,
      # Derive confidence intervals, t-tests and p-values.
      infer = TRUE,
      # Don't adjust the p-values for multiplicity.
      adjust = "none"
    )

    sum_contrasts_level <- sum_contrasts[grepl(sum_level, sum_contrasts$contrast), ]

    list(
      n = length(y[!is.na(y)]),
      lsmean = with_label(sum_fit_level$emmean, "Adjusted Mean"),
      lsmean_diff = with_label(sum_contrasts_level$estimate, "Difference in Adjusted Means"),
      lsmean_diff_ci = with_label(c(sum_contrasts_level$lower.CL,
                                    sum_contrasts_level$upper.CL), tern:::f_conf_level(conf_level)),
      pval = with_label(sum_contrasts_level$p.value, "p-value")
    )
  }
}
```

### Layout Functions
```{r}
summarize_ancova <- function(lyt,
                             vars,
                             var_labels,
                             show_labels = "visible",
                             ...) {
  a_ancova <- tern:::format_wrap_df(
    s_ancova,
    indent_mods = c("n" = 0L, "lsmean" = 0L, "lsmean_diff" = 0L, "lsmean_diff_ci" = 2L, "pval" = 2L),
    formats = c("n" = "xx", "lsmean" = "xx.xx", "lsmean_diff" = "xx.xx", "lsmean_diff_ci" = "xx.xx - xx.xx",
                "pval" = "x.xxxx | (<0.0001)")
  )
  analyze(
    lyt,
    vars,
    var_labels = var_labels,
    show_labels = show_labels,
    afun = a_ancova,
    extra_args = list(...)
  )
}
```

## Application {.tabset .tabset-pills}

### single endpoint
```{r}
n_per_arm <- table(adsl$ARM)

basic_table() %>%
  split_cols_by("ARMCD", ref_group = "ARM A") %>%
  add_colcounts() %>%
  summarize_ancova(vars = "CHG",
                   variables = list(arm = "ARMCD", covariates = NULL),
                   conf_level = 0.95, var_labels = "Unadjusted comparison",
                   .labels = c(lsmean = "Mean", lsmean_diff = "Difference in Means")) %>%
  summarize_ancova(vars = "CHG",
                   variables = list(arm = "ARMCD", covariates = c("BASE", "STRATA1")),
                   conf_level = 0.95, var_labels = "Adjusted comparison (covariates BASE and STRATA1)") %>%
  build_table(adqs_single, col_counts = n_per_arm)
```

### multiple endpoints
```{r}
basic_table() %>%
  split_cols_by("ARMCD", ref_group = "ARM A") %>%
  split_rows_by("PARAMCD") %>%
  summarize_ancova(vars = "CHG",
                   variables = list(arm = "ARMCD", covariates = c("BASE", "STRATA1")),
                   conf_level = 0.95, var_labels = "Adjusted mean") %>%
  build_table(adqs_multi, col_counts = n_per_arm)
```
