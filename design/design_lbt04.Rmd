---
title: "Design for AE by grade table (LBT04)"
author: "Jana Stoilova"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of LBT04}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

Configuration
=============

```{r setup}
library(rtables)
library(tern)
library(dplyr)
library(assertthat)

packageVersion("tern")
packageVersion("rtables")
```

Data for examples
=================
```{r, data}

library(scda)

adlb <- synthetic_cdisc_data("rcd_2021_05_05")$adlb
adsl <- synthetic_cdisc_data("rcd_2021_05_05")$adsl

# Recode ADLB parameters to so that each one has different
# possible abnormalities
# ALT: LOW
# IGA: HIGH
# CRP: LOW, HIGH

adlb$ANRIND[adlb$PARAMCD == "ALT" & adlb$ANRIND == "HIGH"] <- "LOW"
adlb$BNRIND[adlb$PARAMCD == "ALT" & adlb$BNRIND == "HIGH"] <- "LOW"

adlb$ANRIND[adlb$PARAMCD == "IGA" & adlb$ANRIND == "LOW"] <- "HIGH"
adlb$BNRIND[adlb$PARAMCD == "IGA" & adlb$BNRIND == "LOW"] <- "HIGH"

adlb %>% count(PARAMCD, BNRIND, ANRIND)

```

# Current functionality

Our goal is to re-desing the `count_abnormal` layout so that based on a metadata map, the row with "High" records under ALT and "Low" records under IGA can be removed.
```{r, current}
lyt <- basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = drop_split_levels) %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = c(Low = "LOW", High = "HIGH"),
    exclude_base_abn = FALSE
  )

result <- build_table(lyt = lyt, df = adlb, alt_counts_df = adsl)

result
```

# Metadata map

Defines which lab directions are theoretically possible even if they don't exist in the dataset.

```{r, metadata}

# Note here we include "NORMAL" levels as they are needed for defining the denominators
# in the final layout.
map <- data.frame(
  LBCAT = c(rep("CHEMISTRY", 5), rep("IMMUNOLOGY", 2)),
  PARAMCD = c(rep("ALT", 2), rep("CRP", 3), rep("IGA", 2)),
  ANRIND = c("LOW", "NORMAL", "LOW", "HIGH", "NORMAL", "HIGH", "NORMAL"),
  stringsAsFactors = FALSE
)

basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map)) %>%
  analyze("ANRIND") %>%
  build_table(adlb)
```


# Statistics function

Here we update the default `abnormal` to be for multiple directions (previously was either LOW or HIGH). The function will return a list depending on the intersection of the factor levels available in the analysis variable `.var` and the values of `abnormal`.

```{r, sfun}

s_count_abnormal <- function(df,
                             .var,
                             abnormal = c(Low = "LOW", High = "HIGH"),
                             variables = list(id = "USUBJID", baseline = "BNRIND"),
                             exclude_base_abn = FALSE
) {

  # Assertions for abnormal
  assertthat::assert_that(
    is_character_vector(abnormal, min_length = 2, max_length = 2),
    !is.null(names(abnormal)),
    any(abnormal %in% levels(df[[.var]]))
  )

  # This will define the abnormal levels theoretically possible for a specific lab parameter
  # within a split level of a layout.
  abn_levels <- intersect(abnormal, levels(df[[.var]]))
  names(abn_levels) <- names(abnormal)[abnormal %in% abn_levels]

  result <- split(numeric(0), factor(names(abn_levels), levels = names(abn_levels)))

  for (abn in names(abn_levels)) {

    abnormal <- abn_levels[abn]

    # Patients in the denominator fulfill:
    # - have at least one post-baseline visit
    # - their baseline must not be abnormal if `exclude_base_abn`.
    subjects_post_any <- df[[variables$id]]
    subjects_exclude <- if (exclude_base_abn) {
      df[df[[variables$baseline]] == abnormal, ][[variables$id]]
    } else {
      c()
    }
    subjects_denom <- setdiff(subjects_post_any, subjects_exclude)
    denom <- length(subjects_denom)

    # Patients in the numerator fulfill:
    # - have at least one post-baseline visit with the required abnormality level
    # - are part of the denominator patients.
    subjects_post_abnormal <- df[df[[.var]] == abnormal, ][[variables$id]]
    subjects_num <- intersect(subjects_post_abnormal, subjects_denom)
    num <- length(subjects_num)

    result[[abn]] <- with_label(c(num = num, denom = denom), abn)

  }

  result <- list(fraction = result)
  result
}

# Test it out.
s_count_abnormal(adlb %>% filter(PARAMCD == "ALT") %>% droplevels(), .var = "ANRIND")
s_count_abnormal(adlb %>% filter(PARAMCD == "CRP"), .var = "ANRIND")
# switch order of HIGH and LOW
s_count_abnormal(adlb %>% filter(PARAMCD == "CRP"), .var = "ANRIND", abnormal = c(high = "HIGH", low = "LOW"))
```

```{r, afun}
# No changes here.

a_count_abnormal <- make_afun(
  s_count_abnormal,
  .formats = c(fraction = format_fraction)
)

# Just small update to examples:
a_fun <- make_afun(a_count_abnormal, .ungroup_stats = "fraction")
a_fun(adlb %>% filter(PARAMCD == "ALT") %>% droplevels(), .var = "ANRIND")
a_fun(adlb %>% filter(PARAMCD == "CRP"), .var = "ANRIND")
```

# New layout function

Here the main change is using the `.ungroup_stats` argument. Alos it makes sense to remove `abnormal` since it's no longer needed separately from the `...` 
arguments passed to `s_count_abnormal`.

```{r, new_layout}
count_abnormal <- function(lyt,
                           var,
                           ...,
                           table_names = var,
                           .stats = NULL,
                           .formats = NULL,
                           .labels = NULL,
                           .indent_mods = NULL) {

  afun <- make_afun(
    a_count_abnormal,
    .stats = .stats,
    .formats = .formats,
    .labels = .labels,
    .indent_mods = .indent_mods,
    .ungroup_stats = "fraction"
  )
  assert_that(
    is.string(var)
  )

  analyze(
      lyt = lyt,
      vars = var,
      afun = afun,
      table_names = table_names,
      extra_args = list(...),
      show_labels = "hidden"
    )

}

# Final table working as expected:
lyt1 <- basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map)) %>%
  count_abnormal(
    var = "ANRIND",
    exclude_base_abn = FALSE
  )

build_table(lyt1, df = adlb, alt_counts_df = adsl)

# Change exclude_base_abn
lyt2 <- basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map)) %>%
  count_abnormal(
    var = "ANRIND",
    exclude_base_abn = TRUE
  )

build_table(lyt2, df = adlb, alt_counts_df = adsl)

```

# Additional edge cases

Example 1: Case where all `ANRIND` for a parameter are in only one direction.
```{r, anrind_normal_only}

# Here we make a dataset where all observed ALT values are LOW
adlb_f1 <- adlb %>%
  filter(PARAMCD != "ALT" | ANRIND == "NORMAL")

adlb_f1 %>% count(PARAM, ANRIND)

# Works as expected with theoretical map
build_table(lyt1, df = adlb_f1, alt_counts_df = adsl)

# With empirical map we need to remove both ALT NORMAL and LOW
# Even though we observe ALT NORMAL in the database, this will not produce a valid output
# from the layout function.
empirical_map1 <- map %>%
  filter(!(PARAMCD == "ALT" & ANRIND == "LOW"))

empirical_map1

```

The following code results in an error:
```{r, error = TRUE}
basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = empirical_map1)) %>%
  count_abnormal(
    var = "ANRIND",
    exclude_base_abn = FALSE
  ) %>%
  build_table(df = adlb_f1, alt_counts_df = adsl)

# The same error is shown when we use trim_levels_in_group
basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_in_group("ANRIND")) %>%
  count_abnormal(
    var = "ANRIND",
    exclude_base_abn = FALSE
  ) %>%
  build_table(df = adlb_f1, alt_counts_df = adsl)
```

```{r}
# Removing ALT rows from the analysis is done by removing the parameters without any observerd abnormalities
# in the map:
empirical_map2 <- map %>%
  filter(PARAMCD != "ALT")

empirical_map2

basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = empirical_map2)) %>%
  count_abnormal(
    var = "ANRIND",
    exclude_base_abn = FALSE
  ) %>%
  build_table(df = adlb_f1, alt_counts_df = adsl)

```

Example 2: Case where all `ANRIND` for a parameter are LOW.
```{r, anrind_low_only}

# Here we make a dataset where all observed ALT values are NORMAL.
adlb_f2 <- adlb %>%
  filter(PARAMCD != "ALT" | ANRIND == "LOW")

adlb_f2 %>% count(PARAM, ANRIND)

# Works as expected with theoretical map
build_table(lyt1, df = adlb_f2, alt_counts_df = adsl)

# Also works as expected with empirical map
basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_in_group("ANRIND")) %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = c(low = "LOW", high = "HIGH"),
    exclude_base_abn = FALSE
  ) %>%
  build_table(df = adlb_f2, alt_counts_df = adsl)
```

Example 3: Case where all `ANRIND` for a parameter are LOW but map has parameter only in opposite direction (this is error in the map construction):
```{r, error_in_map}

# Here we set the abnormality direction of ALT to be HIGH in the map.
map_alt_high <- map
map_alt_high$ANRIND[map$PARAMCD == "ALT" & map$ANRIND == "LOW"] <- "HIGH"

map_alt_high %>%
  filter(PARAMCD == "ALT") %>%
  count(ANRIND)

# However in the observed data, ALT has only abnormalities in the LOW direction
adlb %>%
  filter(PARAMCD == "ALT") %>%
  count(ANRIND)

basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map_alt_high)) %>%
  count_abnormal(
    var = "ANRIND",
    exclude_base_abn = FALSE
  ) %>%
  build_table(df = adlb, alt_counts_df = adsl)
```

As can be seen in this example, the map ultimately defines what levels appear in the analysis even if they are observed in the data. This may potentially lead to errors and users should be careful when constructing these maps. Likely the addition of helper functions to this package will help reduce this risk as maps for standard safety data should be automatically constructed.
