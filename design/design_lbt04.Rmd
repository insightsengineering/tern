---
title: "Design for AE by grade table (LBT04)"
author: "Jana Stoilova"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of LBT04}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

Configuration
=============

```{r setup}
library(rtables)
library(tern)
library(dplyr)
library(assertthat)

packageVersion("tern")
packageVersion("rtables")
```

Data for examples
=================
```{r, data}

library(scda)

adlb <- synthetic_cdisc_data("rcd_2021_05_05")$adlb
adsl <- synthetic_cdisc_data("rcd_2021_05_05")$adsl

# Recode ADLB parameters to so that each one has different
# possible abnormalities
# ALT: LOW
# IGA: HIGH
# CRP: LOW, HIGH

adlb$ANRIND[adlb$PARAMCD == "ALT" & adlb$ANRIND == "HIGH"] <- "LOW"
adlb$BNRIND[adlb$PARAMCD == "ALT" & adlb$BNRIND == "HIGH"] <- "LOW"

adlb$ANRIND[adlb$PARAMCD == "IGA" & adlb$ANRIND == "LOW"] <- "HIGH"
adlb$BNRIND[adlb$PARAMCD == "IGA" & adlb$BNRIND == "LOW"] <- "HIGH"

adlb %>% count(PARAMCD, BNRIND, ANRIND)

```

# Current functionality

Our goal is to re-desing the `count_abnormal` layout so that based on a metadata map, the row with "High" records under ALT and "Low" records under IGA can be removed.
```{r, current}
lyt <- basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = drop_split_levels) %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = c(Low = "LOW", High = "HIGH"),
    exclude_base_abn = FALSE
  )

result <- build_table(lyt = lyt, df = adlb, alt_counts_df = adsl)

result
```

# Metadata map

Defines which lab directions are theoretically possible even if they don't exist in the dataset.

```{r, metadata}

map <- data.frame(
  LBCAT = c("CHEMISTRY", "CHEMISTRY", "CHEMISTRY", "IMMUNOLOGY"),
  PARAMCD = c("ALT", "CRP", "CRP", "IGA"),
  ANRIND = c("LOW", "LOW", "HIGH", "HIGH"),
  stringsAsFactors = FALSE
)

basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map)) %>%
  analyze("ANRIND") %>%
  build_table(adlb)
```


# Statistics function

Here we update the default `abnormal` to be for multiple directions (previously was either LOW or HIGH). The function will return a list depending on the intersection of the factor levels available in the analysis variable `.var` and the values of `abnormal`.

```{r, sfun}

s_count_abnormal <- function(df,
                             .var,
                             abnormal = c("LOW", "HIGH"),
                             variables = list(id = "USUBJID", baseline = "BNRIND"),
                             exclude_base_abn = FALSE
) {

  # This will define the abnormal levels theoretially possible for a specific lab parameter
  # within a split level of a layout.
  abn_levels <- intersect(abnormal, levels(df[[.var]]))
  
  result <- split(numeric(0), factor(abn_levels, levels = abn_levels))
  
  for (abn in abn_levels) {
    
    abnormal <- abn
    
    # Patients in the denominator fulfill:
    # - have at least one post-baseline visit
    # - their baseline must not be abnormal if `exclude_base_abn`.
    subjects_post_any <- df[[variables$id]]
    subjects_exclude <- if (exclude_base_abn) {
      df[df[[variables$baseline]] == abnormal, ][[variables$id]]
    } else {
      c()
    }
    subjects_denom <- setdiff(subjects_post_any, subjects_exclude)
    denom <- length(subjects_denom)
    
    # Patients in the numerator fulfill:
    # - have at least one post-baseline visit with the required abnormality level
    # - are part of the denominator patients.
    subjects_post_abnormal <- df[df[[.var]] == abnormal, ][[variables$id]]
    subjects_num <- intersect(subjects_post_abnormal, subjects_denom)
    num <- length(subjects_num)
    
    result[[abn]] <- with_label(c(num = num, denom = denom), abn)
    
  }

  result <- list(fraction = result)
  result
}

# Test it out.
s_count_abnormal(adlb %>% filter(PARAMCD == "ALT") %>% droplevels(), .var = "ANRIND")
s_count_abnormal(adlb %>% filter(PARAMCD == "CRP"), .var = "ANRIND")

```

```{r, afun}
# No changes here.

a_count_abnormal <- make_afun(
  s_count_abnormal,
  .formats = c(fraction = format_fraction)
)
```

# New layout function

Here the main change is using the `.ungroup_stats` argument.

```{r, new_layout}

count_abnormal <- function(lyt,
                           var,
                           abnormal,
                           ...,
                           table_names = var,
                           .stats = NULL,
                           .formats = NULL,
                           .labels = NULL,
                           .indent_mods = NULL) {

  afun <- make_afun(
    a_count_abnormal,
    .stats = .stats,
    .formats = .formats,
    .labels = .labels,
    .indent_mods = .indent_mods,
    .ungroup_stats = "fraction"
  )
  assert_that(
    is.string(var)
  )

  analyze(
      lyt = lyt,
      vars = var,
      afun = afun,
      table_names = table_names,
      extra_args = c(list(abnormal = abnormal), list(...)),
      show_labels = "hidden"
    )
  
}

# Final table working as expected: 
basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map)) %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = c("LOW", "HIGH"),
    exclude_base_abn = FALSE
  ) %>%
  build_table(adlb, alt_counts_df = adsl)

basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map)) %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = c("LOW", "HIGH"),
    exclude_base_abn = TRUE
  ) %>%
  build_table(adlb, alt_counts_df = adsl)

```
