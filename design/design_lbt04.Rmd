---
title: "Design for AE by grade table (LBT04)"
author: "Jana Stoilova"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of LBT04}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

Configuration
=============

```{r setup}
library(rtables)
library(tern)
library(dplyr)
library(assertthat)

packageVersion("tern")
packageVersion("rtables")
```

Data for examples
=================
```{r, data}

library(scda)

adlb <- synthetic_cdisc_data("rcd_2021_05_05")$adlb
adsl <- synthetic_cdisc_data("rcd_2021_05_05")$adsl

# Recode ADLB parameters to so that each one has different
# possible abnormalities
# ALT: LOW
# IGA: HIGH
# CRP: LOW, HIGH

adlb$ANRIND[adlb$PARAMCD == "ALT" & adlb$ANRIND == "HIGH"] <- "LOW"
adlb$BNRIND[adlb$PARAMCD == "ALT" & adlb$BNRIND == "HIGH"] <- "LOW"

adlb$ANRIND[adlb$PARAMCD == "IGA" & adlb$ANRIND == "LOW"] <- "HIGH"
adlb$BNRIND[adlb$PARAMCD == "IGA" & adlb$BNRIND == "LOW"] <- "HIGH"

adlb_no_CRP_L <- filter(adlb, !(PARAMCD == "CRP" & ANRIND == "LOW")) # "0" in single row only CRP -> LOW # nolintr
adlb_no_ALT_LN <- filter(adlb, !(PARAMCD == "ALT" & ANRIND %in% c("LOW", "NORMAL"))) # "0" for the whole ALT inner group # nolintr
adlb_no_IGA_NH <- filter(adlb, !(PARAMCD == "IGA" & ANRIND %in% c("HIGH", "NORMAL"))) # "0" for the whole IMMUNOLOGY outer group # nolintr
adlb_no_ALT_LH <- filter(adlb, PARAMCD != "ALT" | ANRIND == "NORMAL") # normal level and no any abnormal level for ALT # nolintr
adlb_no_ALT_NH <- filter(adlb, PARAMCD != "ALT" | ANRIND == "LOW") # normal level and no any abnormal level for ALT # nolintr

# counts (no dropping)
lyt_0 <- basic_table() %>%
  split_rows_by("LBCAT") %>%
  split_rows_by("PARAMCD") %>%
  analyze("ANRIND")

build_table(lyt_0, adlb)
build_table(lyt_0, adlb_no_CRP_L)
build_table(lyt_0, adlb_no_ALT_LN)
build_table(lyt_0, adlb_no_IGA_NH)
build_table(lyt_0, adlb_no_ALT_LH)
build_table(lyt_0, adlb_no_ALT_NH)
```

# Update count_abnormal layout function

Here we update the default `abnormal` to be for multiple directions (previously was either LOW or HIGH). The function will return a list depending on the intersection of the factor levels available in the analysis variable `.var` and the values of `abnormal`.

```{r, update_count_abnormal}

######################
## s_count_abnormal
######################
s_count_abnormal <- function(df,
                             .var,
                             abnormal = list(Low = "LOW", High = "HIGH"),
                             variables = list(id = "USUBJID", baseline = "BNRIND"),
                             exclude_base_abn = FALSE
) {

  # Assertions for abnormal
  assertthat::assert_that(
    is_character_list(abnormal, min_length = 2, max_length = 2),
    !is.null(names(abnormal)),
    any(unlist(abnormal) %in% levels(df[[.var]]))
  )

  count_abnormal_single <- function(abn_name, abn) {

    # Patients in the denominator fulfill:
    # - have at least one post-baseline visit
    # - their baseline must not be abnormal if `exclude_base_abn`.
    if (exclude_base_abn) {
      denom_select <- !(df[[variables$baseline]] %in% abn)
    } else {
      denom_select <- TRUE
    }
    denom <- length(unique(df[denom_select, variables$id, drop = TRUE]))

    # Patients in the numerator fulfill:
    # - have at least one post-baseline visit with the required abnormality level
    # - are part of the denominator patients.
    num_select <- (df[[.var]] %in% abn) & denom_select
    num <- length(unique(df[num_select, variables$id, drop = TRUE]))

    with_label(c(num = num, denom = denom), abn_name)
  }

  # This will define the abnormal levels theoretically possible for a specific lab parameter
  # within a split level of a layout.
  abnormal_lev <- lapply(abnormal, intersect, levels(df[[.var]]))
  abnormal_lev <- abnormal_lev[!sapply(abnormal_lev, is_empty)]

  result <- sapply(names(abnormal_lev), function(i) count_abnormal_single(i, abnormal_lev[[i]]), simplify = FALSE)
  result <- list(fraction = result)
  result

}

# Test it out.
s_count_abnormal(adlb %>% filter(PARAMCD == "ALT") %>% droplevels(), .var = "ANRIND")
s_count_abnormal(adlb %>% filter(PARAMCD == "CRP"), .var = "ANRIND")
# switch order of HIGH and LOW
s_count_abnormal(adlb %>% filter(PARAMCD == "CRP"), .var = "ANRIND", abnormal = list(high = "HIGH", low = "LOW"))

######################
## a_count_abnormal
######################

# No changes here.
a_count_abnormal <- make_afun( # nolint
  s_count_abnormal,
  .formats = c(fraction = format_fraction)
)

# Just small update to examples:
a_fun <- make_afun(a_count_abnormal, .ungroup_stats = "fraction")
a_fun(adlb %>% filter(PARAMCD == "ALT") %>% droplevels(), .var = "ANRIND")
a_fun(adlb %>% filter(PARAMCD == "CRP"), .var = "ANRIND")

######################
## count_abnormal
######################

# Here the main change is using the '.ungroup_stats' argument.
# Also it makes sense to remove 'abnormal' since it is no longer needed separately
# from the '...' arguments passed to 's_count_abnormal'.

count_abnormal <- function(lyt,
                           var,
                           ...,
                           table_names = var,
                           .stats = NULL,
                           .formats = NULL,
                           .labels = NULL,
                           .indent_mods = NULL) {

  afun <- make_afun(
    a_count_abnormal,
    .stats = .stats,
    .formats = .formats,
    .labels = .labels,
    .indent_mods = .indent_mods,
    .ungroup_stats = "fraction"
  )
  assert_that(
    is.string(var)
  )

  analyze(
      lyt = lyt,
      vars = var,
      afun = afun,
      table_names = table_names,
      extra_args = list(...),
      show_labels = "hidden"
    )

}
```

# Standard layout - no "0" records at split

```{r, standard}
lyt <- basic_table() %>%
  split_rows_by("LBCAT", split_fun = drop_split_levels) %>%
  split_rows_by("PARAMCD", split_fun = drop_split_levels) %>%
  # analyze("ANRIND") # nolint
  count_abnormal(
    var = "ANRIND",
    abnormal = list(Low = "LOW", High = "HIGH"),
    exclude_base_abn = FALSE
  )

build_table(lyt = lyt, df = adlb, alt_counts_df = adsl)
build_table(lyt = lyt, df = adlb_no_CRP_L, alt_counts_df = adsl)
build_table(lyt = lyt, df = adlb_no_ALT_LN, alt_counts_df = adsl) # whole ALT dropped due to drop_split_levels at PARAMCD # nolint
build_table(lyt = lyt, df = adlb_no_IGA_NH, alt_counts_df = adsl) # whole IMMUNOLOGY dropped due to drop_split_levels LBCAT # nolint
build_table(lyt = lyt, df = adlb_no_ALT_LH, alt_counts_df = adsl) # CHEMISTRY -> ALT remains as there CHEMISTRY -> ALT -> NORMAL records exist # nolint
build_table(lyt = lyt, df = adlb_no_ALT_NH, alt_counts_df = adsl)

# Change exclude_base_abn
basic_table() %>%
  split_rows_by("LBCAT", split_fun = drop_split_levels) %>%
  split_rows_by("PARAMCD", split_fun = drop_split_levels) %>%
  # analyze("ANRIND") # nolint
  count_abnormal(
    var = "ANRIND",
    abnormal = list(Low = "LOW", High = "HIGH"),
    exclude_base_abn = TRUE
  ) %>%
  build_table(df = adlb, alt_counts_df = adsl)

```

Despite the fact that we drop split levels, there might be still some "0" records in the leafs of the tree as they come from count_abnormal.
For the majority of cases we can drop these "0" leaf records too, using trim_levels_in_group split function.
However, there is a one case when this approach does not work as `count_abnormal` requires that at least one abnormal level is present
in a data for a given study variable. Even if we modify `count_abnormal` so that we relax this requirement, it must still return something 
which will then appear in the final output. So if there are such specific cases to handle, the `trim_levels_to_map` should be used 
(see the next paragraph). 

# Standard layout - no "0" records at all with exception

```{r, standard_no_0_records}
lyt_no0 <- basic_table() %>%
  split_rows_by("LBCAT", split_fun = drop_split_levels) %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_in_group("ANRIND")) %>% # we also trim levels of ANRIND
  # analyze("ANRIND") # nolint
  count_abnormal(
    var = "ANRIND",
    abnormal = list(Low = "LOW", High = "HIGH"),
    exclude_base_abn = FALSE
  )

build_table(lyt = lyt_no0, df = adlb, alt_counts_df = adsl)
build_table(lyt = lyt_no0, df = adlb_no_CRP_L, alt_counts_df = adsl) # no CHEMISTRY/ALT/HIGH, CHEMISTRY/CRP/LOW, IMMUNOLOGY/IGA/LOW due to trim_levels_in_group # nolint
build_table(lyt = lyt_no0, df = adlb_no_ALT_LN, alt_counts_df = adsl) # whole ALT and IMMUNOLOGY/IGA/LOW dropped due to trim_levels_in_group # nolint
build_table(lyt = lyt_no0, df = adlb_no_IGA_NH, alt_counts_df = adsl) # whole IMMUNOLOGY dropped due to drop_split_levels LBCAT and CHEMISTRY/ALT/HIGH due to trim_levels_in_group # nolint
build_table(lyt = lyt_no0, df = adlb_no_ALT_LH, alt_counts_df = adsl) # FAILS at count_abnormal as there are only normal levels (no abnormal) # nolint
build_table(lyt = lyt_no0, df = adlb_no_ALT_NH, alt_counts_df = adsl) # no CHEMISTRY/ALT/HIGH, IMMUNOLOGY/IGA/LOW due to trim_levels_in_group # nolint

```

# Metadata map layout

Based on a metadata map, some of the levels of split and inner variables can be removed before layout function.
Using this feature, we can define which lab directions are theoretically possible even if they don't exist in the data set.

```{r, map}

# We do know upfront (i.e. without exploratory data analysis and regardless of any particular instance of the data)
# that some records will always be "0", and hence these records may not be displayed,
# regardless of whether or not other "0" records (if any) are supposed to be displayed.
# For instance, CHEMISTRY -> ALT -> HIGH as well as IMMUNOLOGY -> IGA -> LOW are an examples of such "0" records.

# Note here we include "NORMAL" levels as they are needed for defining the denominators
# in the final layout.

map <- data.frame(
  LBCAT = c(rep("CHEMISTRY", 5), rep("IMMUNOLOGY", 2)),
  PARAMCD = c(rep("ALT", 2), rep("CRP", 3), rep("IGA", 2)),
  ANRIND = c("LOW", "NORMAL", "LOW", "HIGH", "NORMAL", "HIGH", "NORMAL"),
  stringsAsFactors = FALSE
)
map

lyt_map <- basic_table() %>%
  split_rows_by("LBCAT", split_fun = drop_split_levels) %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map)) %>%
  #analyze("ANRIND") %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = list(Low = "LOW", High = "HIGH"),
    exclude_base_abn = FALSE
  )

build_table(lyt = lyt_map, df = adlb, alt_counts_df = adsl)
build_table(lyt = lyt_map, df = adlb_no_CRP_L, alt_counts_df = adsl)
build_table(lyt = lyt_map, df = adlb_no_ALT_LN, alt_counts_df = adsl)
build_table(lyt = lyt_map, df = adlb_no_IGA_NH, alt_counts_df = adsl)
build_table(lyt = lyt_map, df = adlb_no_ALT_LH, alt_counts_df = adsl)
build_table(lyt = lyt_map, df = adlb_no_ALT_NH, alt_counts_df = adsl)

# Another example of map, here we remove ALT from the previous map.

map_no_ALT <- filter(map, PARAMCD != "ALT") # nolint
map_no_ALT

lyt_map_no_ALT <- basic_table() %>% # nolint
  split_rows_by("LBCAT", split_fun = drop_split_levels) %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map_no_ALT)) %>%
  #analyze("ANRIND") %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = list(Low = "LOW", High = "HIGH"),
    exclude_base_abn = FALSE
  )

build_table(lyt = lyt_map_no_ALT, df = adlb, alt_counts_df = adsl)
build_table(lyt = lyt_map_no_ALT, df = adlb_no_CRP_L, alt_counts_df = adsl)
build_table(lyt = lyt_map_no_ALT, df = adlb_no_ALT_LN, alt_counts_df = adsl)
build_table(lyt = lyt_map_no_ALT, df = adlb_no_IGA_NH, alt_counts_df = adsl)
build_table(lyt = lyt_map_no_ALT, df = adlb_no_ALT_LH, alt_counts_df = adsl)
build_table(lyt = lyt_map_no_ALT, df = adlb_no_ALT_NH, alt_counts_df = adsl)

# Here we set the abnormality direction of ALT to be HIGH in the map.
map_ALT_H <- map # nolint
map_ALT_H$ANRIND[map$PARAMCD == "ALT" & map$ANRIND == "LOW"] <- "HIGH"

lyt_map_ALT_H <- basic_table() %>% # nolint
  split_rows_by("LBCAT", split_fun = drop_split_levels) %>%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map_ALT_H)) %>%
  #analyze("ANRIND") %>%
  count_abnormal(
    var = "ANRIND",
    abnormal = list(Low = "LOW", High = "HIGH"),
    exclude_base_abn = FALSE
  )

build_table(lyt = lyt_map_ALT_H, df = adlb, alt_counts_df = adsl)
build_table(lyt = lyt_map_ALT_H, df = adlb_no_CRP_L, alt_counts_df = adsl)
build_table(lyt = lyt_map_ALT_H, df = adlb_no_ALT_LN, alt_counts_df = adsl)
build_table(lyt = lyt_map_ALT_H, df = adlb_no_IGA_NH, alt_counts_df = adsl)
build_table(lyt = lyt_map_ALT_H, df = adlb_no_ALT_LH, alt_counts_df = adsl)
build_table(lyt = lyt_map_ALT_H, df = adlb_no_ALT_NH, alt_counts_df = adsl)
```

As can be seen in this example, the map ultimately defines what levels appear in the analysis even if they are observed in the data. This may potentially lead to errors and users should be careful when constructing these maps. Likely the addition of helper functions to this package will help reduce this risk as maps for standard safety data should be automatically constructed.
To remove all "0" records, the data should be first examined and then the map should be created. This is so called empirical map, in contrast to (theoretical) map which can be built upfront, without the need of exploring of the actual data set.
