title: "Design for MNG01"
author:
  - Yuliia Bahatska
  - Wojciech Wojciak
date: "`r Sys.Date()`"
output:
  html_document:
  toc: true
toc_float: true
toc_depth: 2
theme: journal
highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design of MNG01}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

## Configuration
```{r setup}
library(dplyr)
library(ggplot2)
library(tern)

```

## Data for examples
```{r data, results = "asis", eval = TRUE}

adlb <- scda::synthetic_cdisc_data("latest")$adlb

adlb <- adlb %>%
  filter(ANL01FL == "Y",
         PARAMCD == "ALT",
         AVISIT != "SCREENING") %>%
  df_explicit_na()

```

## TEMPORARY - UNTIL ALL THE PREREQS ARE AVAILABLE
```{r temp}

s_summary.numeric <- function(x, # nolint
                              na.rm = TRUE, # nolint
                              denom,
                              .N_row, # nolint
                              .N_col, #nolint
                              na_level,
                              .var,
                              control = control_summarize_vars(),
                              ...) {
  assert_that(is.numeric(x))
  
  control_diff <- setdiff(names(control_summarize_vars()), names(control))
  control <- c(control, control_summarize_vars()[control_diff])

  if (na.rm) {
    x <- x[!is.na(x)]
  }

  y <- list()

  y$n <- c("n" = length(x))

  y$mean <- c("mean" = ifelse(length(x) == 0, NA_real_, mean(x, na.rm = FALSE)))

  y$sd <- c("sd" = sd(x, na.rm = FALSE))

  y$mean_sd <- c(y$mean, "sd" = sd(x, na.rm = FALSE))

  mean_ci <- stat_mean_ci(x, conf_level = control$conf_level, na.rm = FALSE, gg_helper = FALSE)
  y$mean_ci <- with_label(mean_ci, paste("Mean", f_conf_level(control$conf_level)))

  mean_se <- y$mean[[1]] + c(-1, 1) * sd(x, na.rm = FALSE) / sqrt(y$n)
  names(mean_se) <- c("mean_se_lwr", "mean_se_upr")
  y$mean_se <- with_label(mean_se, "Mean -/+ 1xSE")

  mean_sdi <- y$mean[[1]] + c(-1, 1) * sd(x, na.rm = FALSE)
  names(mean_sdi) <- c("mean_sdi_lwr", "mean_sdi_upr")
  y$mean_sdi <- with_label(mean_sdi, "Mean -/+ 1xSD")

  y$median <- c("median" = median(x, na.rm = FALSE))

  median_ci <- stat_median_ci(x, conf_level = control$conf_level, na.rm = FALSE, gg_helper = FALSE)
  y$median_ci <- with_label(median_ci, paste("Median", f_conf_level(control$conf_level)))

  q <- control$quantiles
  if (any(is.na(x))) {
    qnts <- rep(NA_real_, length(q))
  } else {
    qnts <- quantile(x, probs = q, type = control$quantile_type, na.rm = FALSE)
  }
  names(qnts) <- paste("quantile", q, sep = "_")
  y$quantiles <- with_label(qnts, paste0(paste(paste0(q * 100, "%"), collapse = " and "), "-ile"))

  y$iqr <- c("iqr" = ifelse(
    any(is.na(x)),
    NA_real_,
    IQR(x, na.rm = FALSE, type = control$quantile_type))
  )

  y$range <- setNames(range_noinf(x, na.rm = FALSE), c("min", "max"))

  y
}

summary_numeric_format <- function() {
  c(n = "xx.",
    mean = "xx.x",
    sd = "xx.x",
    mean_sd = "xx.x (xx.x)",
    mean_ci = "(xx.xx, xx.xx)",
    mean_se = "(xx.xx, xx.xx)",
    mean_sdi = "(xx.xx, xx.xx)",
    median = "xx.x",
    median_ci = "(xx.xx, xx.xx)",
    quantiles = "xx.x - xx.x",
    iqr = "xx.x - xx.x",
    range = "xx.x - xx.x")
}

summary_numeric_labels <- function() {
  c(mean = "Mean",
    sd = "SD",
    mean_sd = "Mean (SD)",
    median = "Median",
    iqr = "IQR",
    range = "Min - Max")
}

```
## New function to display graphs 
```{r fun} 

# Helper function to get the right cell formatting in the the table.
format_row <- function(x, format, labels = NULL) {

  format_cell <- function(x, format, label = NULL) {
    fc <- rtables::format_rcell(x = x, format = format)
    x_label <- attr(x, "label")
    if (!is.null(label) && !is.na(label))
      names(fc) <- label
    else if (!is.null(x_label) && !is.na(x_label))
      names(fc) <- x_label
    else if (length(x) == length(fc))
      names(fc) <- names(x)
    as.data.frame(t(fc)) # cell: one row, one column data.frame
  }

  row <- dplyr::bind_cols(
    lapply(
      names(x), function(n) format_cell(x[[n]], format = format[n], label = labels[n])
    )
  )

  row
}

# New plot function.
g_lineplot <- function(df, x = "AVISIT", y = "AVAL", strata = "ARM", na.rm = TRUE, # nolint
                       mid = "mean", interval = "mean_ci", whiskers = c("lwr", "upr"), table = NULL,
                       stat_fun = tern::s_summary.numeric, control = tern::control_summarize_vars(), 
                       table_format = tern::summary_numeric_format(), table_labels = tern::summary_numeric_labels(),
                       mid_type = "pl", mid_point_size = 2, position = position_dodge(width = 0.4),
                       legend_position = "bottom", legend_title = NULL,
                       x_lab = "Visit", y_lab = "ALT", y_lab_units_var = "AVALU",
                       title = "Plot of Mean and 95% Confidence Limits by Visit",
                       caption = NULL) {

  assert_that(is.character(x))
  assert_that(is.character(y))
  assert_that(is.character(strata) || is.null(strata))
  assert_that(is.character(mid) || is.null(mid))
  assert_that(is.character(interval) || is.null(interval))
  assert_that(ifelse(is.character(interval), all(whiskers %in% c("lwr", "upr")), TRUE))
  assert_that(ifelse(length(whiskers) == 1, is.character(mid), TRUE))
  assert_that(
    ifelse(
      is.character(mid),
      (length(mid_type) == 1) && mid_type %in% c("pl", "p", "l"),
      TRUE
    )
  )

  ## Compute required statistics.
  df_grp <- group_by_at(df, c(strata, x))
  df_stats <- summarise(
    df_grp,
    bind_cols(
      lapply(
        stat_fun(.data[[y]], control = control, na.rm = na.rm)[c(mid, interval)],
        function(x) as_tibble(t(x))
      )
    ),
    .groups = "drop"
  )

  # add number of objects N in strata
  if (!is.null(strata)) {

    df_N <- df %>% # nolint
      group_by_at(strata) %>%
      summarise(N = ifelse(na.rm, sum(!is.na(.data[[y]])), n()), .groups = "drop")
    
    df_stats <- dplyr::full_join(x = df_stats, y = df_N, by = strata)

    strata_N <- paste0(strata, "_N") # nolint
    df_stats[[strata_N]] <- paste0(df_stats[[strata]], " (N = ", df_stats$N, ")")

  }

  ## Prepare certain plot's properties

  # y label
  if (!is.null(y_lab_units_var)) {
    unit <- unique(df[[y_lab_units_var]])
    stopifnot("y_lab_units_var must be in df and df[[y]] must be of the same units" = length(unit) == 1) # nolint
    y_lab <- paste0(y_lab, " (", unit, ")")
  }

  # legend title
  if (is.null(legend_title) && !is.null(strata) && legend_position != "none") {
    legend_title <- attr(df[[strata]], "label")
  }

  ## Build plot object.
  p <- ggplot(
    data = df_stats,
    mapping = aes_string(
      x = x, y = mid, color = strata_N, shape = strata_N, lty = strata_N, group = strata_N
    ))

  if (!is.null(mid)) {
    # points
    if (grepl("p", mid_type, fixed = TRUE)) {
      p <- p + geom_point(position = position, size = mid_point_size)
    }

    # lines
    if (grepl("l", mid_type, fixed = TRUE)) {
      # for line graphs, the data points must be grouped so that it knows which points to connect.
      m <- if (is.null(strata)) aes(group = 1)
      p <- p + geom_line(mapping = m, position = position)
    }
  }

  if (!is.null(interval)) {

    yminmax <- paste(interval, whiskers, sep = "_")

    p <- p +
      geom_errorbar(
        aes_string(ymin = yminmax[1], ymax = yminmax[max(1, length(whiskers))]),
        width = 0.45,
        position = position
      )

    if (length(whiskers) == 1) { # lwr or upr only; mid is then required
      #workaround as geom_errorbar does not provide single-direction whiskers
      p <- p +
        geom_linerange(
          aes_string(ymin = mid, ymax = yminmax),
          position = position,
          show.legend = FALSE
        )
    }
  }

  p <- p +
    scale_y_continuous(labels = scales::comma, expand = expansion(c(0.25, .25))) +
    theme_bw() +
    theme(
      legend.key.width = unit(1, "cm"),
      legend.position = legend_position,
      legend.direction = ifelse(
        legend_position %in% c("top", "bottom"),
        "horizontal",
        "vertical")
    ) +
    labs(
      title = title,
      caption = caption,
      color = legend_title,
      lty = legend_title,
      shape = legend_title,
      x = x_lab,
      y = y_lab
    )

  # Optionally, add table to the bottom of the plot
  if (!is.null(table)) {

    df_stats_table <- df_grp %>%
      summarise(
        format_row(
          x = stat_fun(.data[[y]], control = control, na.rm = na.rm)[table],
          format = table_format,
          labels <- table_labels
        ),
        .groups = "drop"
      )

    stats_lev <- rev(setdiff(colnames(df_stats_table), c(strata, x)))

    df_stats_table <- df_stats_table %>%
      tidyr::pivot_longer(
        cols = -c(strata, x),
        names_to = "stat",
        values_to = "value",
        names_ptypes = list(stat = factor(levels = stats_lev))
    )

    tbl <- ggplot(df_stats_table, aes_string(x = x, y = "stat", label = "value", color = strata)) +
      geom_text(size = 3) +
      theme_bw() +
      theme(
        panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 5)),
        strip.text = element_text(hjust = 0),
        strip.text.x = element_text(margin = margin(1.5, 0, 1.5, 0, "pt")),
        strip.background = element_rect(fill = "grey95", color = NA),
        legend.position = "none"
      ) +
      facet_wrap(as.formula(paste("~", strata)), ncol = 1)

    p <- ggpubr::ggarrange(p, tbl, heights = c(3, 1), ncol = 1, nrow = 2, align = "v")
    # alternatively, below code can be used if the above is having problems with
    # horizontal alignment of x axis. This happens when the facet variables are the same
    # and there are no legends - a kind of bug in ggpubr::ggarrange
    # p <- p / tbl + plot_layout(heights = c(3, 1)) # patchwork R package is required # nolint

  }

  return(p)

}

```


## Examples
```{r examples} 

# Mean with CI
g_lineplot(adlb)
# temp
# g_lineplot(adlb, stat_fun = s_summary.numeric, table_format = summary_numeric_format(), table_labels = summary_numeric_labels())

# Mean, upper whisker of CI
g_lineplot(adlb, whiskers = "upr", title = "Plot of Mean and Upper 95% Confidence Limit by Visit")
# temp
# g_lineplot(adlb, whiskers = "upr", title = "Plot of Mean and Upper 95% Confidence Limit by Visit",
#            stat_fun = s_summary.numeric, table_format = summary_numeric_format(), table_labels = summary_numeric_labels())

# Median with CI
g_lineplot(adlb, mid = "median", title = "Plot of Median and 95% Confidence Limits by Visit")
# temp
# g_lineplot(adlb, mid = "median", title = "Plot of Median and 95% Confidence Limits by Visit",
#            stat_fun = s_summary.numeric, table_format = summary_numeric_format(), table_labels = summary_numeric_labels())

# Mean, +/- SD
g_lineplot(adlb, interval = "mean_sdi", title = "Plot of Median +/- SD by Visit")
# temp
# g_lineplot(adlb, interval = "mean_sdi", title = "Plot of Median +/- SD by Visit",
#            stat_fun = s_summary.numeric, table_format = summary_numeric_format(), table_labels = summary_numeric_labels())

# Mean with CI plot with stats table
g_lineplot(adlb, table = c("n", "mean", "mean_ci"))
# temp
# g_lineplot(adlb, table = c("n", "mean", "mean_ci"),
#            stat_fun = s_summary.numeric, table_format = summary_numeric_format(), table_labels = summary_numeric_labels())

# Mean with CI - continuous time variable, customized confidence level
g_lineplot(adlb, x = "AVISITN", table = c("n", "mean"), control = list(conf_level = 0.80),
           title = "Plot of Mean and 80% Confidence Limits by Visit")
# temp
# g_lineplot(adlb, x = "AVISITN", table = c("n", "mean"), control = list(conf_level = 0.80),
#            title = "Plot of Mean and 80% Confidence Limits by Visit",
#            stat_fun = s_summary.numeric, table_format = summary_numeric_format(), table_labels = summary_numeric_labels())
```
