---
title: "Design: ECG Qualitative Assessment Shift Table (EGT04)"
author: "Daniel Sabanes Bove"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Design of EGT04}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

## Configuration

```{r setup}
library(rtables)
library(tern)

packageVersion("tern")
packageVersion("rtables")
```

```{r data, results = "asis", eval = TRUE}

library(random.cdisc.data)

ADSL <- radsl(cached = TRUE)
ADEG <- radeg(cached = TRUE)
adeg_labels <- formatable::var_labels(ADEG)

ADEG_f <- subset(
  ADEG,
  PARAMCD == "ECGINTP" & # Analysis in terms of "NORMAL"/"ABNORMAL" (AVALC)
    SAFFL == "Y" & # "Safety Population Flag"
    ONTRTFL == "Y" & # "On Treatment Record Flag"
    WORS02FL == "Y" # "Worst Post-Baseline Observation"
)


# Preprocessing

# For the EGT04 template, data imputation shoud be avoided, and missing data
# explicit and accounted for, so the contingency table sum adds up to the group N.
# For illustration purpose, missing data are added to the example.
ADEG_f$AVALC[sample(1:nrow(ADEG_f), size = 5)] <- "Missing"
ADEG_f$BASEC[sample(1:nrow(ADEG_f), size = 5)] <- "Missing"
ADEG_f$AVALC <- factor(
  ADEG_f$AVALC,
  levels = c("NORMAL", "ABNORMAL", "Missing"),
  labels = c("Normal", "Abnormal", "Missing")
)
ADEG_f$BASEC <- factor(
  ADEG_f$BASEC,
  levels = c("NORMAL", "ABNORMAL", "Missing"),
  labels = c("Normal", "Abnormal", "Missing")
)

formatable::var_labels(ADEG_f) <- adeg_labels
```

## Design Proposition

The final functions should make this workable:

```{r target, eval = FALSE}
lyt <- basic_table() %>%
  split_cols_by("AVALC") %>%
  split_rows_by("ARM") %>%
  add_rowcounts() %>%
  summarize_vars("BASEC", by_row = TRUE)

build_table(lyt = lyt, df = ADEG_f)
```

## Function `c_label_n` to use in `summarize_row_groups`

This function just produces a label consisting of the label of the level that is being summarized followed by the `N` in parentheses. Important is here to not use `df` but `.N_row`, because the former
is already split by columns and will refer to the first column only.

We can then add a speaking layout creating function, which is parallel to `add_colcounts()`: `add_rowcounts`.

Let's try this out in a simple example.

``` {r label example}
basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  split_rows_by("RACE", split_fun = drop_split_levels) %>%
  add_rowcounts() %>%
  analyze("AGE", afun = list_wrap_x(summary), format = "xx.xx") %>%
  build_table(DM)
```

Ideas for later:

- This should be added to `rtables` eventually.
- Interestingly, it seems there was a function `summarize_row_groups_count` before in `rtables` already,
  but it is no longer there. At least it is mentioned in likely outdated Developers vignette.

## Function `s_summary.factor` 

Note that we will have several applications of this method for the S3 generic `s_summary`.
This is just one of them. We therefore will need to keep updating the method definition in `tern`
as we add more TLGC entries. The tests will be critical to ensure that we keep existing TLGC entries
working.

Since here we need additional arguments, we will need to modify `s_summary` to forward additional
arguments with an ellipsis to the methods. The argument `denom` specifies whether percentages are
normalized to cells (default) columns (by using `N_col`) or rows (`N_row`).

Further we need to add `.N_row` and `.N_col` to the signature of the generic `s_summary` such that
the Analyze Function `summarize_vars` can really pass this down to our `s_summary.factor` method.

We map our standard `na.rm` argument to the `useNA` argument of `table`.

Further, in order to increase usability, we can have a character summary method 
that does a conversion to factor and then calls the factor method.

Let's try this out in a simple example. We add the row and column counts so that we can check
the fractions are correct.

``` {r summary example}
basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  split_rows_by("SEX", split_fun = drop_split_levels) %>%
  add_rowcounts() %>%
  summarize_vars("RACE") %>%
  build_table(DM)

basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  split_rows_by("SEX", split_fun = drop_split_levels) %>%
  add_rowcounts() %>%
  summarize_vars("RACE", denom = "N_row") %>%
  build_table(DM)
```

## Putting everything together

Finally we can execute our preferred code.

```{r target achieved}
lyt <- basic_table() %>%
  split_cols_by("AVALC") %>%
  split_rows_by("ARM") %>%
  add_rowcounts() %>%
  summarize_vars("BASEC", denom = "N_row")

build_table(lyt = lyt, df = ADEG_f)
```
