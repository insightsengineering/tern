---
title: "Design for Pruning Functions Family"
output: html_document
editor_options:
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{Design for Pruning Functions Family}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#",
  dev = "svg"
)

library(assertthat)
library(random.cdisc.data)
library(tern)
```

## Objective

We would like to have a good user interface that implements the many different options
of occurrence data pruning described in the corresponding [section of the design doc](https://docs.google.com/document/d/1ZjE4TA4hTEsfS87TEDRg_1Mw_7sLE_WE174uL_YKKe8/edit#bookmark=id.el285jyc2r7c).

## Idea

The idea is to have function constructors that implement the "atomic" pruning rules and that can be combined with logical "and" and "or" operators to more complex pruning rules. For example, in order to prune with a rule that keeps analysis rows and corresponding content rows:

- At least occurs in 5% of all patients, and
- Has a difference of at least 2% between occurrence of the active treatment arms,

the implementation could look similar like this:

```{r eval=FALSE}
build_table(df) %>%
  prune_table(
    prune_occurrences(
      has_percent_all(above = 0.05) &
      has_difference_arms(above = 0.02, arms = c("Active", "Combination"))
    )
  )
```

## Logical combinations of functions

In order to be able to define methods for the logical operators `&` and `|` we need to use classes for the constructed functions. Fortunately we the required S4 overhead is pretty small. See this toy example:

```{r}
setClass("myclass", contains = "function")

higher <- function(a) {
  force(a)
  methods::new(
    "myclass",
    function(x) {
      x > a
    }
  )
}

lower <- function(b) {
  force(b)
  methods::new(
    "myclass",
    function(x) {
      x < b
    }
  )
}

setMethod(
  "&",
  signature = c(e1 = "myclass", e2 = "myclass"),
  definition = function(e1, e2) {
    function(x) {
      e1(x) & e2(x)
    }
  })

c1 <- higher(5)
c2 <- lower(10)

c3 <- higher(5) & lower(10)
c3(7)
```


## Function constructors

### Occurrence Pruning

In principle, for occurrence table pruning we can follow a similar approach as `prune_empty_level()` does:
- Remove all analysis rows (`TableRow`) that should be pruned, that is, don't fulfill the requirements.
- Remove the subtable if there are no children left.
Since most table specifications are worded positively (see the example above), we name our functions positively too. The result of `keep_occurrences` says what should be pruned though, to conform with the `prune_table` interface.

We can calculate some things from the `TableTree` object:
- Index of the "All Levels" column (if there is one)

```{r}
keep_occurrences <- function(keep_row_conditions, all_name = "All Patients") {
  function(tt) {
    all_levels_index <- grep(all_name, names(tt))
    if (is(tt, "TableRow"))
      return(! keep_row_conditions(
        table_row = tt,
        all_levels_index = all_levels_index
      ))
    children <- tree_children(tt)
    identical(length(children), 0L)
  }
}
```

We define a custom S4 class for the condition functions and define logical operations between them.

```{r}
setClass("OccurrenceCondition", contains = "function")

new_condition <- function(fun) {
  methods::new("OccurrenceCondition", fun)
}

setMethod(
  "&",
  signature = c(e1 = "OccurrenceCondition", e2 = "OccurrenceCondition"),
  definition = function(e1, e2) {
    new_condition(function(...) {
      e1(...) && e2(...)
    })
  })

setMethod(
  "|",
  signature = c(e1 = "OccurrenceCondition", e2 = "OccurrenceCondition"),
  definition = function(e1, e2) {
    new_condition(function(...) {
      e1(...) || e2(...)
    })
  })

setMethod(
  "!",
  signature = c(x = "OccurrenceCondition"),
  definition = function(x) {
    function(...) {
      !x(...)
    }
  })
```

### Conditions for "Occurrence in All Patients"

To implement the `has_percent_all()` condition constructor, we can expect the standard `TableTree` information to be passed down to use from `keep_occurrences()`. Note that it is important that we evaluate the `above` argument of this function constructor, see `[https://adv-r.hadley.nz/function-factories.html#forcing-evaluation]` for more background. Here we achieve this as a side effect of the assertion that `above` is a proportion.

```{r}
has_percent_all <- function(above) {
  assertthat::assert_that(
    is_proportion(above)
  )
  new_condition(function(table_row, all_levels_index, ...) {
    assertthat::assert_that(
      assertthat::is.count(all_levels_index),
      msg = "All levels column must be present to apply `has_percent_all` condition"
    )
    row_vals <- row_values(table_row)
    all_vals <- row_vals[[all_levels_index]]
    all_percent <- all_vals[2L]
    assertthat::assert_that(
      is_proportion(all_percent, include_boundaries = TRUE)
    )
    all_percent > above
  })
}
```

Similarly, we can do the same for the count values.

```{r}
has_count_all <- function(above) {
  assertthat::assert_that(
    assertthat::is.count(above)
  )
  new_condition(function(table_row, all_levels_index, ...) {
    assertthat::assert_that(
      assertthat::is.count(all_levels_index),
      msg = "All levels column must be present to apply `has_counts_all` condition"
    )
    row_vals <- row_values(table_row)
    all_vals <- row_vals[[all_levels_index]]
    all_count <- all_vals[1L]
    assertthat::assert_that(
      is_nonnegative_count(all_count)
    )
    all_count > above
  })
}
```

### Conditions for "Difference between Treatment Arms"

```{r}
has_percent_difference <- function(above, arms) {
  assertthat::assert_that(
    is_proportion(above),
    is.character(arms),
    length(arms) > 1
  )
  new_condition(function(table_row, ...) {
    assertthat::assert_that(
      all(arms %in% names(table_row)),
      msg = "not all arms for differences found in the table column names"
    )
    arm_indices <- match(arms, names(table_row))
    row_vals <- row_values(table_row)[arm_indices]
    row_percentages <- sapply(row_vals, "[", 2L)
    diff_percentages <- diff(range(row_percentages))
    diff_percentages > above
  })
}
```

And again the same can be done for counts.

```{r}
has_count_difference <- function(above, arms) {
  assertthat::assert_that(
    assertthat::is.count(above),
    is.character(arms),
    length(arms) > 1
  )
  new_condition(function(table_row, ...) {
    assertthat::assert_that(
      all(arms %in% names(table_row)),
      msg = "not all arms for `has_count_difference` found in the table column names"
    )
    arm_indices <- match(arms, names(table_row))
    row_vals <- row_values(table_row)[arm_indices]
    row_counts <- sapply(row_vals, "[", 1L)
    diff_counts <- diff(range(row_counts))
    diff_counts > above
  })
}
```

Note that there is some overlap between the function code here, so in the production stage we might combine these into a joint backend function. The function name is still nice to keep distinct and speaking to avoid too many arguments.

### Conditions for "Occurrence in Selected Arms"

Now we would like to specify minimum percentage or counts when looking at selected treatment arms only. The logic that is used in this prototype is that the counts from the selected arms are pooled together. The resulting value (percent or count) is then compared vs. the threshold.

```{r}
has_count_arms <- function(above, arms) {
  assertthat::assert_that(
    assertthat::is.count(above),
    is.character(arms)
  )
  new_condition(function(table_row, ...) {
    assertthat::assert_that(
      all(arms %in% names(table_row)),
      msg = "not all arms for `has_count_arms` found in the table column names"
    )
    arm_indices <- match(arms, names(table_row))
    row_vals <- row_values(table_row)[arm_indices]
    row_counts <- sapply(row_vals, "[", 1L)
    total_count <- sum(row_counts)
    total_count > above
  })
}
```

Similar for percent. Here we can use the `col_counts` accessor function to get the column totals from the `TableRow` object.

```{r}
has_percent_arms <- function(above, arms) {
  assertthat::assert_that(
    is_proportion(above),
    is.character(arms)
  )
  new_condition(function(table_row, ...) {
    assertthat::assert_that(
      all(arms %in% names(table_row)),
      msg = "not all arms for `has_percent_arms` found in the table column names"
    )
    arm_indices <- match(arms, names(table_row))
    row_vals <- row_values(table_row)[arm_indices]
    row_counts <- sapply(row_vals, "[", 1L)
    total_count <- sum(row_counts)
    total_n <- sum(col_counts(table_row)[arm_indices])
    total_percent <- total_count / total_n
    total_percent > above
  })
}
```

## `MHT01` example

We can take for starters the `MHT01` table, variant 5, as example table.

```{r}
adsl <- radsl(cached = TRUE)
n_per_arm <- table(adsl$ARM)
n_per_arm_tot <- c(n_per_arm, "All Patients" = sum(n_per_arm))

admh <- radmh(cached = TRUE)

lyt <- basic_table() %>%
  split_cols_by("ARM", split_fun = add_overall_level("All Patients", first = FALSE)) %>%
  add_colcounts() %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = c("unique"),
    .labels = c(unique = "Total number of patients with at least one event")
  ) %>%
  split_rows_by("MHBODSYS", split_fun = drop_split_levels, child_labels = "visible", nested = FALSE) %>%
  summarize_num_patients(
    var = "USUBJID",
    .stats = c("unique"),
    .labels = c(unique = "Total number of patients with at least one event")
  ) %>%
  count_occurrences("MHDECOD")

result <- build_table(lyt, admh, col_counts = n_per_arm_tot)
result
```

Let's try to apply the simplest pruning here. We can define things consecutively to be able to debug better.

```{r}
fun_conditions <- has_percent_all(above = 0.35) &
  has_percent_difference(above = 0.05, arms = c("A: Drug X", "C: Combination")) &
  has_percent_arms(above = 0.2, arms = c("A: Drug X", "C: Combination"))
prune_fun <- keep_occurrences(
  fun_conditions
)

result %>%
  prune_table(prune_fun)
```

So this seems to work as intended.

## AET04 example

Now let's look at the more complicated grade specific conditions. For this let's look at the AET04 design from Jana to get an example.

```{r}
library(random.cdisc.data)

adsl <- radsl(cached = TRUE)
adae <- radae(cached = TRUE)

adae$AEDECOD2 <- as.character(adae$AEDECOD) #nolint
adae$AEBODSYS2 <- as.character(adae$AEBODSYS) #nolint

anl <- adae %>%
  dplyr::filter(AEDECOD %in% c("dcd A.1.1.1.1", "dcd A.1.1.1.2") | AEBODSYS == "cl B.1")

df <- data.frame(
  USUBJID = as.character(c(1:5, 1)),
  ATOXGR = factor(c(1, 2, 3, 1, 2, 3), levels = c(1:5)),
  AESEV = factor(c("MILD", "MODERATE", "SEVERE", "MILD", "MODERATE", "SEVERE")),
  ARM = factor(c("A", "A", "A", "B", "B", "A")),
  stringsAsFactors = FALSE
)

big_n <- length(unique(anl$USUBJID))

s_count_grade_per_id <- function(df,
                                 .var,
                                 .N_col, #nolint
                                 id = "USUBJID") {

  assertthat::assert_that(
    assertthat::(df[, c(.var, id)]),
    is.factor(df[[.var]])
  )

  id <- df[[id]] #nolint
  grade <- df[[.var]]

  grade <- factor(grade, levels = levels(grade), ordered = TRUE) # needed to take maximum
  df_max <- aggregate(grade ~ id, FUN = max, drop = FALSE)

  l_count <- as.list(table(df_max$grade))

  l_count_percent <- lapply(l_count, function(i, denom) c(i, i / denom), denom = .N_col)

  list(
    count_percent = l_count_percent
  )

}

s_count_grade_per_id(df, .var = "ATOXGR", .N_col = 10)

s_count_grade_per_id_content <- function(
  df,
  labelstr = "",
  .N_col, # nolint
  .var,
  id = "USUBJID") {

  assertthat::assert_that(
    is.data.frame(df),
    assertthat::is.string(.var)
  )

  result <- s_count_grade_per_id(
    df = df,
    .var = .var,
    .N_col = .N_col,
    id = id
  )
  any_grade <- sum(vapply(tern:::flatten_list(result), `[[`, i = 1, numeric(1)))
  any <- list("any" = with_label(c(any_grade, any_grade / .N_col), "- Any Grade -"))

  c(any, grade = unname(result))
}

s_count_grade_per_id_content(df, .var = "ATOXGR", .N_col = 10)


count_grade_per_id <- function(lyt, vars, ...) {

  afun <- tern:::format_wrap_df(
    s_count_grade_per_id,
    indent_mods = c(count_percent = 0L),
    formats = c(count_percent = "xx (xx.x%)")
  )

  analyze(
    lyt = lyt,
    vars = vars,
    afun = afun,
    extra_args = list(...)
  )

}

basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  count_grade_per_id("ATOXGR") %>%
  build_table(df, col_counts = table(df$ARM))

# creation of content function with default arguments:
c_grade_per_id <- make_afun(
  s_count_grade_per_id_content,
  .stats = c("any", "grade"),
  .formats = c(any = "xx (xx.x%)", "grade" = "xx (xx.x%)"),
  .indent_mods = c("any" = 0L, "grade" = 0L)
)

args(c_grade_per_id)
c_grade_per_id(
  df,
  .N_col = 2,
  .var = "ATOXGR"
)

# customization can happen in 2nd call to `make_afun`
c_grade_per_id2 <- make_afun(
  c_grade_per_id,
  .stats = c("grade"),
  .ungroup_stats = "grade"
)
c_grade_per_id2(
  df,
  .N_col = 2,
  .var = "ATOXGR"
)

summarize_grade_per_id <- function(
  lyt,
  var,
  .stats = NULL,
  .formats = NULL,
  .indent_mods = NULL,
  ...
  ) {

  c_grade_per_id_customized <- make_afun(
    c_grade_per_id,
    .stats = .stats,
    .formats = .formats,
    .indent_mods = .indent_mods,
    .ungroup_stats =
      `if`(
        is.null(.stats) || "grade" %in% .stats,
        "grade",
        NULL
      )# Note that we need to ungroup only here.
    # Otherwise for the user they could no longer refer to `grade` statistic.
  )

  summarize_row_groups(
    lyt = lyt,
    var = var,
    cfun = c_grade_per_id_customized,
    extra_args = list(...)
  )
}

```


Try this out:

```{r}
basic_table() %>%
  split_cols_by("ARM") %>%
  add_colcounts() %>%
  summarize_grade_per_id("ATOXGR") %>%
  build_table(df, col_counts = table(df$ARM))
```

More complex table:

```{r}
result <- basic_table() %>%
  add_colcounts() %>%
  summarize_grade_per_id("AETOXGR") %>%
  split_rows_by("AEBODSYS2", child_labels = "visible", nested = FALSE) %>%
  summarize_grade_per_id("AETOXGR") %>%
  split_rows_by("AEDECOD2", child_labels = "visible", nested = TRUE) %>%
  summarize_grade_per_id("AETOXGR", .stats = c("any")) %>%
  count_grade_per_id(vars = "AETOXGR") %>%
  build_table(anl, col_counts = big_n)
```



### Grade specific conditions

```{r}
debug_fun <- function(tt) {
    all_levels_index <- grep("AllLevelsSentinel", names(tt))
    content <- rtables::content_table(tt)
    children <- tree_children(tt)
    child_classes <- unique(sapply(children, class))
    if (identical(child_classes, "ElementaryTable")) {
      print("this is a leaf")
    }
    FALSE
  }

result %>% prune_table(debug_fun)
```

New:

- Now we want to use the "Any Grade" row that is in the content table when we are in a leaf to make the decision whether to prune
  this whole subtable or not.
- Since the content row itself is again the same thing essentially as the table row we used for the pruning performed above, we can apply the same condition functions there.
- So we just need a new wrapper pruning function that checks when we are in a leaf and then applies
  the conditions, see `keep_graded_occurrences` below.

```{r}
# Helper function which says whether current table is a leaf in the tree.
is_leaf_table <- function(tt) {
  children <- tree_children(tt)
  child_classes <- unique(sapply(children, class))
  identical(child_classes, "ElementaryTable")
}

# Helper function to get first row of content table of current table.
get_content_as_row <- function(tt) {
  ct <- content_table(tt)
  tree_children(ct)[[1]]
}

# The new wrapper pruning constructor.
keep_graded_occurrences <- function(keep_row_conditions) {
  function(tt) {
    all_levels_index <- grep("AllLevelsSentinel", names(tt))
    if (is_leaf_table(tt)) {
      tr <- get_content_as_row(tt)
      return(! keep_row_conditions(
        table_row = tr,
        all_levels_index = all_levels_index
      ))
    }
    if (is(tt, "DataRow")) {
      return(FALSE)
    }
    children <- tree_children(tt)
    identical(length(children), 0L)
  }
}
```

Let's try this out:

```{r}
fun_conditions <- has_percent_arms(above = 0.5, arms = "all obs")
prune_fun <- keep_graded_occurrences(
  fun_conditions
)

result %>%
  prune_table(prune_fun)
```

Did not work initially without `stop_depth`, as `DataRow` objects are still accessed here and since they don't have children they all got pruned. Therefore we needed to check for that and make sure that those are not pruned at all on their own.

## Old and no longer applicable/important

### Specific grade info pruning

If we wanted to use specific grade rows for pruning decisions (but we don't want that) then:

- We can find the variable name of the current `TableTree` with `obj_name()`. If that equals the toxicity grade variable (here `AETOXGR`) we can start looking for the grade specific info in the rows of the object.
- We can then see the toxicity grade by `row.names()` applied to the row or whole table object.
- It seems that a) since we need to sum across grades and b) since the pruning of the e.g. grade 1-2 rows depends on the pruning decision made on grade 3-4 rows, we can here no longer apply the concept from above, of considering each row independently.
- Instead we will need to work on the whole subtable and prune it or not.
- So we will need something like `keep_grade_occurrences()` high level pruning function, and then apply a `stop_depth` to not look at individual rows at all.
