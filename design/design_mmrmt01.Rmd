---
title: "Design for MMRM tables"
author: "Daniel Sabanes Bove"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    theme: journal
    highlight: zenburn
vignette: >
  %\VignetteIndexEntry{Design for MMRM tables}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svg"
)
```

## Configuration

```{r setup}
library(rtables)
library(tern)
library(assertthat)
library(dplyr)
library(random.cdisc.data)

packageVersion("tern")
packageVersion("rtables")
```

## Data for examples

We just take the same as in the `fit_mmrm` help page:

```{r}
adsl <- radsl(cached = TRUE)
adqs <- radqs(cached = TRUE)
adqs_f <- adqs %>%
  dplyr::filter(PARAMCD == "FKSI-FWB" & !AVISIT %in% c("BASELINE")) %>%
  droplevels() %>%
  dplyr::mutate(ARMCD = factor(ARMCD, levels = c("ARM B", "ARM A", "ARM C"))) %>%
  dplyr::mutate(
    AVISITN = rank(AVISITN) %>%
    as.factor() %>%
    as.numeric() %>%
    as.factor()
  )
var_labels(adqs_f) <- var_labels(adqs)
```

## Model fitting

The model fitting pretty much stays the same as before. We have renamed `s_mmrm` to `fit_mmrm` to follow our new naming convention that we want "expressive verbs" for user facing functions.

```{r}
mmrm_results <- fit_mmrm(
  vars = list(
    response = "AVAL",
    covariates = c("STRATA1", "BMRKR2"),
    id = "USUBJID",
    arm = "ARMCD",
    visit = "AVISIT"
  ),
  data = adqs_f,
  cor_struct = "unstructured",
  weights_emmeans = "equal",
  optimizer = "nloptwrap_neldermead"  # Only to speed up this example.
)
```

So we have our `mmrm` object here.

## Helper functions

Let's see if helper functions from old `tern` still work more or less.

```{r}
as.rtable <- function(x, ...) {  #nolint
  UseMethod("as.rtable", x)
}

as.rtable.data.frame <- function(x, format = "xx.xx") { # nolint
  do.call(
    rtable,
    c(
      list(
        header = names(x),
        format = format
      ),
      Map(
      function(row, row.name) {
        do.call(rrow,
                c(as.list(unname(row)),
                  row.name = row.name))
      },
      row = as.data.frame(t(x)), row.name = rownames(x)
      )
    )
  )
}

x <- data.frame(
  a = 1:10,
  b = rnorm(10)
)
test <- as.rtable(x)
test
class(test)
```

That seems to work, nice. Let's try the `cbind` (at least for simple elementary tables):

```{r}
cbind.rtables <- function(...) { # nolint
  all_args <- list(...)
  stopifnot(all(sapply(all_args, is, "ElementaryTable")))
  current <- all_args[[1]]
  while (length(all_args <- all_args[-1]) > 0) {
    current <- rtables::cbind_rtables(current, all_args[[1]])
  }
  return(current)
}

table1 <- as.rtable(data.frame(a = 5, b = 3))
table2 <- as.rtable(data.frame(c = 5, d = 9))
table3 <- as.rtable(data.frame(bla = 10))
cbind.rtables(table1, table2, table3)
```

Also works, cool.

## Simple tables

Let's start with the simple tables, that maybe don't need a lot of work in terms of tabulation if the manual tabulation framework still works ok. However, we might consider a more clever generic tabulation function together with a `type` argument to avoid the previous `t_mmrm_*` functions. We can just use again `as.rtable`.

### Fixed effects

So let's tackle fixed effects first.

```{r}
t_mmrm_fixed <- function(object, format = "xx.xxxx") {
  fixed_table <- as.data.frame(coef(summary(object$fit)))
  pvalue_column <- match("Pr(>|t|)", names(fixed_table))
  df_column <- match("df", names(fixed_table))
  pvalue_table <- as.rtable(fixed_table[, pvalue_column, drop = FALSE], format = "x.xxxx | (<0.0001)")
  df_table <- as.rtable(fixed_table[, df_column, drop = FALSE], format = "xx.")  # xx. rounds to 0 digits.
  remaining_table <- as.rtable(fixed_table[, - c(df_column, pvalue_column), drop = FALSE], format = format)
  cbind.rtables(remaining_table, df_table, pvalue_table)
}

t_mmrm_fixed(mmrm_results)
```

Then we can link this (and then others below too) from our generic method:

```{r}
as.rtable.mmrm <- function(x, type = "fixed") {
  type <- match.arg(type)
  if (type == "fixed") {
    t_mmrm_fixed(x)
  }
}

as.rtable(mmrm_results, type = "fixed")
```

## Covariance matrix

This one also works out of the box:

```{r}
t_mmrm_cov <- function(object, format = "xx.xxxx") {
  cov_estimate <- object$cov_estimate
  as.rtable(as.data.frame(cov_estimate), format = format)
}

t_mmrm_cov(mmrm_results)
```

## Diagnostic statistics

OK this one we rewrite to make it less ugly.

```{r}
s_mmrm_diagnostic <- function(df, ...) {
  as.list(df[c("REML.criterion", "AIC", "AICc", "BIC")])
}

a_mmrm_diagnostic <- make_afun(
  s_mmrm_diagnostic,
  .labels = c(REML.criterion = "REML criterion")
)

t_mmrm_diagnostic <- function(object, format = "xx.xxxx") {
  diag_values <- object$diagnostics
  df <- as.data.frame(diag_values)
  lyt <- basic_table()
  lyt <- analyze(lyt, vars = "AIC", afun = a_mmrm_diagnostic, format = format)
  build_table(lyt, df)
}

t_mmrm_diagnostic(mmrm_results)
```

Maybe there is a way to change the column header here?

## Complicated table

Now we get to the more complicated LS means table.

First we write our `tidy` method:

```{r}
library(broom)
tidy.mmrm <- function(object) {  #nolint
  contrasts <- object$lsmeans$contrasts
  estimates <- object$lsmeans$estimates
  vars <- object$vars
  contrasts[[vars$arm]] <- factor(contrasts[[vars$arm]], levels = levels(estimates[[vars$arm]]))
  df <- merge(
    x = estimates,
    y = contrasts,
    by = c("ARMCD", "AVISIT"),
    suffixes = c("_est", "_contr"),
    all = TRUE
  )
  df$conf_level <- object$conf_level
  as_tibble(df)
}

tidy_results <- tidy(mmrm_results)
```

Then we have our Statistics function:

```{r}
s_mmrm_lsmeans <- function(df, .in_ref_col, show_relative = c("reduction", "increase")) {
  show_relative <- match.arg(show_relative)
  if_not_ref <- function(x) `if`(.in_ref_col, character(), x)
  list(
    n = df$n,
    adj_mean_se = c(df$estimate_est, df$se_est),
    adj_mean_ci = with_label(c(df$lower_cl_est, df$upper_cl_est), tern:::f_conf_level(df$conf_level)),
    diff_mean_se = if_not_ref(c(df$estimate_contr, df$se_contr)),
    diff_mean_ci = with_label(if_not_ref(c(df$lower_cl_contr, df$upper_cl_contr)), tern:::f_conf_level(df$conf_level)),
    change = switch(
      show_relative,
      reduction = with_label(if_not_ref(df$relative_reduc), "Relative Reduction (%)"),
      increase = with_label(if_not_ref(- df$relative_reduc), "Relative Increase (%)")
    ),
    p_value = if_not_ref(df$p_value)
  )
}

s_mmrm_lsmeans(tidy_results[8, ], FALSE, "reduction")
```

And our corresponding and resulting Formatted Analysis function:

```{r}
a_mmrm_lsmeans <- make_afun(
  s_mmrm_lsmeans,
  .labels = c(
    adj_mean_se = "Adjusted Mean (SE)",
    diff_mean_se = "Difference in Adjusted Means (SE)",
    p_value = "p-value (MMRM)"
  ),
  .formats = c(
    n = "xx.",
    adj_mean_se = sprintf_format("%.3f (%.3f)"),
    adj_mean_ci = "(xx.xxx, xx.xxx)",
    diff_mean_se = sprintf_format("%.3f (%.3f)"),
    diff_mean_ci = "(xx.xxx, xx.xxx)",
    change = "xx.x%",
    p_value = "x.xxxx | (<0.0001)"
  ),
  .indent_mods = c(
    adj_mean_ci = 1L,
    diff_mean_ci = 1L,
    change = 1L,
    p_value = 1L
  ),
  .null_ref_cells = FALSE
)

a_mmrm_lsmeans(tidy_results[8, ], FALSE, "reduction")
```

Note that we always include the `change` statistic but the user can subset all statistics with the `.stats` argument below.
Also we need to disable `.null_ref_cells` since we control this ourselves as we need to show the estimates LS means for the reference column. (So that column is not completely empty.)

Now we have our Analyze Function:

```{r}
summarize_lsmeans <- function(lyt,
                              ...,
                              .stats = NULL,
                              .formats = NULL,
                              .indent_mods = NULL,
                              .labels = NULL) {
  afun <- make_afun(
    a_mmrm_lsmeans,
    .stats = .stats,
    .formats = .formats,
    .indent_mods = .indent_mods,
    .labels = .labels
  )
  analyze(
    lyt = lyt,
    vars = "n",
    afun = afun,
    extra_args = list(...)
  )
}
```

And we can try it in the end all together:

```{r}
basic_table() %>%
  split_cols_by("ARMCD", ref_group = mmrm_results$ref_level) %>%
  add_colcounts() %>%
  split_rows_by("AVISIT") %>%
  summarize_lsmeans(show_relative = "increase") %>%
  build_table(
    df = tidy(mmrm_results),
    col_counts = table(adsl$ARMCD)
  )
```

